{"title":"i++和++i哪個快?","uid":"328642e73045afd436ec2a938d320e13","slug":"C++SideQuest/SQ001 i++和++i哪個快","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T14:43:00.616Z","comments":true,"path":"api/articles/C++SideQuest/SQ001 i++和++i哪個快.json","keywords":null,"cover":"/pic/photo (4).jpg","content":"<h2 id=\"支線任務1\"><a href=\"#支線任務1\" class=\"headerlink\" title=\"支線任務1\"></a>支線任務1</h2><h2 id=\"i-和-i哪個快\"><a href=\"#i-和-i哪個快\" class=\"headerlink\" title=\"i++和++i哪個快?\"></a>i++和++i哪個快?</h2><p>i++ : 後加</p>\n<p>++i : 前加</p>\n<p>你知道對於電腦來說，哪個更快嗎?</p>\n<h1 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h1><p>在這兩個簡單函數中，寫出前加和後加的分別:</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void fun_1()\n&#123;\n    int i &#x3D; 1;\n    int a &#x3D; ++i;\n&#125;\n\nvoid fun_2()\n&#123;\n    int i &#x3D; 1;\n    int a &#x3D; i++;\n&#125;</code></pre>\n\n<p>而如果在編譯器的角度來看，它們的匯編指令為:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fun_1():\n        push    rbp\n\n        #(int i &#x3D; 1;)\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], 1 \n\n        #(int a &#x3D; ++i;)\n        add     DWORD PTR [rbp-4],\n        mov     eax, DWORD PTR [rbp-4]\n        mov     DWORD PTR [rbp-8], eax\n\n        nop\n        pop     rbp\n        ret\nfun_2():\n        push    rbp\n\n        #(int i &#x3D; 1;)\n        mov     rbp, rsp \n        mov     DWORD PTR [rbp-4], 1\n\n        #(int a &#x3D; i++;)\n        mov     eax, DWORD PTR [rbp-4]\n        lea     edx, [rax+1]\n        mov     DWORD PTR [rbp-4], edx\n        mov     DWORD PTR [rbp-8], eax\n\n        nop\n        pop     rbp\n        ret</code></pre>\n\n<p>如果不懂匯編代碼也沒有關係，只知道越少指令行效率越快就可以了(沒有循環的話)</p>\n<p>注意到: fun_1 和 fun_2 之間的分別多了一行匯編碼</p>\n<p>因此在對比++i和i++的效率的時候，我們可以說++i比i++更好</p>\n<h1 id=\"那多出來的匯編碼是甚麼\"><a href=\"#那多出來的匯編碼是甚麼\" class=\"headerlink\" title=\"那多出來的匯編碼是甚麼?\"></a>那多出來的匯編碼是甚麼?</h1><ol>\n<li>前加:</li>\n</ol>\n<pre class=\"line-numbers language-add\" data-language=\"add\"><div class=\"caption\"><span>DWORD PTR [rbp-4] ``` 很容易理解</span></div><code class=\"language-add\">\n2. 後加:\n\n&#96;&#96;&#96; lea     edx, [rax+1] &#96;&#96;&#96; 先實現自加1的運算，然後放在臨時變量edx中(1+1 &#x3D; 2，現在edx中存放著2)\n\n&#96;&#96;&#96; mov     DWORD PTR [rbp-4], edx&#96;&#96;&#96; 把臨時變量edx 拷貝複製給了變量i\n\n# 為何後加要增加多一個臨時變量再拷貝複製?\n\n因為i++的返回值2是右值型的，右值的臨時變量只能夠給別人賦值\n\n而++i是左值型的，左值可以被直接賦值\n\n在看看另外一個例子:\n&#96;&#96;&#96;c++\nvoid fun_3()\n&#123;\n    int i &#x3D; 1;\n    ++i &#x3D; 2; #可以把2賦值給&quot;左值&quot;\n    i++ &#x3D; 2; #不能把2賦值給&quot;右值，編譯器無法編譯\n&#125;</code></pre>\n\n<h1 id=\"即便多了一行匯編碼，這差距也很小不是嗎\"><a href=\"#即便多了一行匯編碼，這差距也很小不是嗎\" class=\"headerlink\" title=\"即便多了一行匯編碼，這差距也很小不是嗎?\"></a>即便多了一行匯編碼，這差距也很小不是嗎?</h1><p>正確的，現代CPU一秒可以運行幾百萬行指令，這兩個幾乎沒有差別，在int類型你喜歡用哪個就用哪個。</p>\n<p>不過對於別的類型來說，當我們需要實現一個class對象的自增，前加的效率會比後加的效率來得高。比如我們製作出一隻怪物，想要讓怪物npc對象自增，那麼在後加的過程就會需要一系列的臨時變量來紀錄怪物的血量，攻擊力，防禦力等等，那就不會是幾節內存能搞定的事情了。</p>\n<h1 id=\"備忘\"><a href=\"#備忘\" class=\"headerlink\" title=\"備忘\"></a>備忘</h1><p><a href=\"https://godbolt.org/\">https://godbolt.org/</a></p>\n","feature":null,"text":"支線任務1i++和++i哪個快?i++ : 後加 ++i : 前加 你知道對於電腦來說，哪個更快嗎? 解答在這兩個簡單函數中，寫出前加和後加的分別: void fun_1() &#123; int i &#x3D; 1; int a &#x3D; ++i; &#125; void...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"C/C++筆記","slug":"C-C-筆記","count":5,"path":"api/categories/C-C-筆記.json"}],"tags":[{"name":"C++","slug":"C","count":5,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%AF%E7%B7%9A%E4%BB%BB%E5%8B%991\"><span class=\"toc-text\">支線任務1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#i-%E5%92%8C-i%E5%93%AA%E5%80%8B%E5%BF%AB\"><span class=\"toc-text\">i++和++i哪個快?</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">解答</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%82%A3%E5%A4%9A%E5%87%BA%E4%BE%86%E7%9A%84%E5%8C%AF%E7%B7%A8%E7%A2%BC%E6%98%AF%E7%94%9A%E9%BA%BC\"><span class=\"toc-text\">那多出來的匯編碼是甚麼?</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%B3%E4%BE%BF%E5%A4%9A%E4%BA%86%E4%B8%80%E8%A1%8C%E5%8C%AF%E7%B7%A8%E7%A2%BC%EF%BC%8C%E9%80%99%E5%B7%AE%E8%B7%9D%E4%B9%9F%E5%BE%88%E5%B0%8F%E4%B8%8D%E6%98%AF%E5%97%8E\"><span class=\"toc-text\">即便多了一行匯編碼，這差距也很小不是嗎?</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%82%99%E5%BF%98\"><span class=\"toc-text\">備忘</span></a>","author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}},"mapped":true,"prev_post":{"title":"免費／付費美術資源地址整合","uid":"49a7cda1ef4bef3570774e1eafffcfe0","slug":"art_asset","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T16:33:12.026Z","comments":true,"path":"api/articles/art_asset.json","keywords":null,"cover":"/pic/photo (2).jpg","text":"免費／付費美術資源地址整合 Unity 官方商店 免費和付費 各類資源 Unreal 官方商店 免費和付費， 每月都會免費放出一些收費素材(記得白嫖) 各類資源 DAZstudio DAZstudio全稱Digital Art Zone studio DazStudio主要是藉用...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"美術資源","slug":"美術資源","count":1,"path":"api/categories/美術資源.json"}],"tags":[{"name":"Art","slug":"Art","count":1,"path":"api/tags/Art.json"}],"author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}}},"next_post":{"title":"神寄的ASCII碼","uid":"d19b343b2530697581da27d289c3281f","slug":"C++SideQuest/SQ002 神寄的ASCII碼","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T16:43:07.092Z","comments":true,"path":"api/articles/C++SideQuest/SQ002 神寄的ASCII碼.json","keywords":null,"cover":"https://images-ext-2.discordapp.net/external/zhXgArubreAgTXm3YViD1wz8d7Enp25eEHPbzrnJQEI/https/pbs.twimg.com/media/FiPYzwfVUAAfH8-.jpg","text":"支線任務2神寄的ASCII碼在以下代碼中，在strig[]中字符數組中，存放著’→’，目標是輸出當前符號的ASCII碼 解釋一下為何strig[]明明只存在一個符號，卻可以輸出兩個完全不一樣的ASCII碼? int main() &#123; char strig[] &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":743,"symbolsTime":"1 mins."},"categories":[{"name":"C/C++筆記","slug":"C-C-筆記","count":5,"path":"api/categories/C-C-筆記.json"}],"tags":[{"name":"C++","slug":"C","count":5,"path":"api/tags/C.json"}],"author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}},"feature":null}}