{"title":"HLSL 入門和基本函數","uid":"364a4cad820c2b7aa61aea1e7f6bce5d","slug":"GraphicQuest/GQ003 HLSL入門和基本函數","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T16:27:39.291Z","comments":true,"path":"api/articles/GraphicQuest/GQ003 HLSL入門和基本函數.json","keywords":null,"cover":"https://cdn.discordapp.com/attachments/1032335453988335676/1042702739274203168/20221105_194029.jpg","content":"<h1 id=\"HLSL-入門和基本函數\"><a href=\"#HLSL-入門和基本函數\" class=\"headerlink\" title=\"HLSL 入門和基本函數\"></a>HLSL 入門和基本函數</h1><p>什麼是HLSL？</p>\n<p>高階著色器語言（High Level Shader Language，簡稱HLSL），就是用來編寫shader的一種語言</p>\n<p>類似的語言還有：</p>\n<h2 id=\"CG\"><a href=\"#CG\" class=\"headerlink\" title=\"CG\"></a>CG</h2><p>它是由NVIDIA公司所開發的，基於C語言同時被OpenGL和Direct3D所支持的開發語言，其語法和HLSL類似。在《GPU編程與CG語言之陽春白雪》中雖然曾認為CG會越來越受歡迎，但遺憾的是，NVIDIA還是拋棄了CG，目前CG的最終版本是3.1。雖然在一些簡單的shader編寫上還是可以使用，但是在新的硬件環境下還是可能不支持，且對一些新功能的支持較差。</p>\n<h2 id=\"GLSL\"><a href=\"#GLSL\" class=\"headerlink\" title=\"GLSL\"></a>GLSL</h2><p>GLSL是基於OpenGL的接口，其語法體係自成一家。但是它不支持DirectX，就不得不放棄僅支持DirectX的Xbox等平台。</p>\n<h2 id=\"HLSL\"><a href=\"#HLSL\" class=\"headerlink\" title=\"HLSL\"></a>HLSL</h2><p>HLSL是由微軟開發的，在Windows平台上一家獨大，多用於遊戲領域。語法類似CG語言，在Unity中CG和HLSL等價。</p>\n<h1 id=\"常用函數分類\"><a href=\"#常用函數分類\" class=\"headerlink\" title=\"常用函數分類\"></a>常用函數分類</h1><ol>\n<li>基本數學運算</li>\n<li>冪指對函數</li>\n<li>數據範圍類</li>\n<li>類型判斷類</li>\n<li>三角函數與雙曲線函數</li>\n<li>向量與矩陣類</li>\n<li>光線運算類</li>\n<li>1D紋理查找</li>\n<li>2D紋理查找</li>\n<li>3D紋理查找</li>\n<li>立體紋理查找</li>\n</ol>\n<h1 id=\"基本數學運算\"><a href=\"#基本數學運算\" class=\"headerlink\" title=\"基本數學運算\"></a>基本數學運算</h1><p>| 函數名 | 用途<br>|——\t|——-<br>| max（a，b） | 返回較大的 |<br>| min（a，b） |\t返回較小的 |<br>| mul（a，b） | 兩向量相乘，常用於矩陣運算 |<br>| abs（a）\t  | 返回a的絕對值 |<br>| round（x）  | 返回與x最近的整數 |<br>| sqrt（x）\t  | 返回x的平方根 |<br>| rsqrt（x）  | 返回x的平方根的倒數 |<br>| degrees（x）| 將弧度轉化為角度 |<br>| redians（x）| 將角度轉化為弧度 |<br>| noise（x）  | 噪聲函數,在每個像素點上輸出0&#x2F;1可形成噪波圖 |</p>\n<h1 id=\"冪指對函數\"><a href=\"#冪指對函數\" class=\"headerlink\" title=\"冪指對函數\"></a>冪指對函數</h1><p>| 函數名 | 用途 | 數學式<br>|——\t|——- |——-<br>| pow（x，y） | x的y次冪（x、y都可以是自變量或具體數）| $x^{y}$ |<br>| exp（x）| 返回以e為底的指數函數 | $e$ |<br>| exp2（value x）|\t返回以2為底，x為指數的冪 | $2^{x}$ |<br>| ldexp（x，exp）|\t返回與2的exp次方的乘積 | $x<em>2^{exp}$ |<br>| log（x）|\t返回指定值的以e為底數的對數 | $lnx$ |<br>| log10（x）| 求以10為底的對數 | $log_{10}x$ |<br>| log2（x）\t| 求以2為底數的對數 | $log_{2}x$ |<br>| frexp（x，out exp）|\t將浮點數分解成尾數和指數，x的返回值是尾數,exp參數返回的值是指數（加上out會返回exp和規格化小數）| $x&#x3D;ret</em>2^{exp}$ |</p>\n<h1 id=\"類型判斷類\"><a href=\"#類型判斷類\" class=\"headerlink\" title=\"類型判斷類\"></a>類型判斷類</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|ceil（x）|\t返回&gt;&#x3D;x的最小整數（向下取整）<br>|floor（x）|\t返回&lt;&#x3D;x的最大整數（向上取整）<br>|step（x，y）|\tx&lt;&#x3D;y返回1（真），否則返回0<br>|saturate（x）|\t返回將x箝制到[0,1]範圍之間的值<br>|clamp（x，min，max）|\t將x限制在[min，max]範圍的值，比min小返回min，比max大返回max<br>|fmord（x，y）|\t返回x對y取餘的餘數<br>|frac（x）|\t取x的小數部分<br>|modf（x，out ip）|\t將x分為小數和整數部分（輸出的ip為整數部分，返回值為小數部分）<br>|lerp（x，y，s）|\t按照s在x到y之間插值，返回<br>|smoothstep（min，max，x）|\t如果x在[min，max]範圍內，就返回介於[0，1]之間的平滑Hermite插值，使用smoothstep在兩個值創建平滑過渡， 例如平滑地混合兩種顏色</p>\n<h1 id=\"三角函數與雙曲線函數\"><a href=\"#三角函數與雙曲線函數\" class=\"headerlink\" title=\"三角函數與雙曲線函數\"></a>三角函數與雙曲線函數</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|sin（x）、cos（x）、tan（x）|三角函數（弧度製：$1°&#x3D;π&#x2F;180 rad$）<br>|asin（x）、acos（x）、atan（x）|\t反三角函數<br>|sincos（x，out s，out c）|\t返回x的正弦和余弦<br>|tan（y，x）|\t返回$y&#x2F;x$的正切<br>|atan2（y，x）|\t返回$y&#x2F;x$的反正切<br>|sinh（x）|\t返回$x$的雙曲正弦值<br>|cosh（x）|\t返回$x$的雙曲餘弦值<br>|tanh（x）|\t返回$x$的雙曲正弦值</p>\n<h1 id=\"向量與矩陣類\"><a href=\"#向量與矩陣類\" class=\"headerlink\" title=\"向量與矩陣類\"></a>向量與矩陣類</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|length(v)|\t返迴向量的長度<br>|normalize(v)|\t向量歸一化，x&#x2F;length(x) 方向向量歸一化<br>|distance(a,b)|\t返回兩個向量之間的距離，不平行的兩個向量應該為0，此處表示為根號下各分量之差的平方和<br>|dot(a,b)\t|返回a和b兩向量的點積<br>|cross(a,b)|\t返回a和b兩向量的叉積，返回值是向量，並且與a,b都垂直<br>|determinant(m)\t|返回指定浮點矩陣的按行列式方式計算的值<br>|transpose(m)|\t返回矩陣m的轉置矩陣</p>\n<h1 id=\"光線運算類\"><a href=\"#光線運算類\" class=\"headerlink\" title=\"光線運算類\"></a>光線運算類</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|reflect(i,n)| 以i為入射向量n為法線方向的反射光<br>|refract(i,n,ri)|\t以i為入射向量n為法線方向,ri為折射率的折射光<br>|lit(n_dot_l,n_dot_h，m)|\t輸入標量(normal,light,半角向量h,鏡面反射係數m) 返迴光照向量(環境光，漫反射光，鏡面高光反射，1)該計算依據的是BlingPhong光照模型<br>|faceforward(n,i,ng)|\t得到面向視圖方向的曲面法向量輸入輸出為同元向量,返回-n*sign(dot(i,ng))(normal,light,normal)</p>\n<h1 id=\"紋理查找\"><a href=\"#紋理查找\" class=\"headerlink\" title=\"紋理查找\"></a>紋理查找</h1><p>紋理查找就是GPU在片元處理階段中在屏幕空間的XY坐標系中對每一個像素對應的紋理查找對應的紋素來確定像素的顏色</p>\n<p>1D紋理其實就是一條線，可看做一維數組，2D可看做二維數組（面），3D三維（體）</p>\n<h1 id=\"1D紋理查找-幾乎不用\"><a href=\"#1D紋理查找-幾乎不用\" class=\"headerlink\" title=\"1D紋理查找 (幾乎不用)\"></a>1D紋理查找 (幾乎不用)</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|tex1D(s, t)|\t普通一維紋理查找 返迴紋理採樣器s在標量t位置的color4<br>|tex1D(s,t,ddx,ddy)|\t使用微分查詢一維紋理， t和ddxy均為vector<br>|tex1Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4<br>|tex1Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的一維紋理查找<br>|tex1Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的一維紋理查找<br>|tex1Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢</p>\n<h1 id=\"2D紋理查找\"><a href=\"#2D紋理查找\" class=\"headerlink\" title=\"2D紋理查找\"></a>2D紋理查找</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|tex2D(s, t)|\t普通二維紋理查找 返迴紋理採樣器s在vector t位置的顏色<br>|tex2D(s,t,ddx,ddy)|\t使用微分查詢二維紋理，t和ddxy均為vector<br>|tex2Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4<br>|tex2Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的二維紋理查找<br>|tex2Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的二維紋理查找<br>|tex2Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢</p>\n<h1 id=\"3D紋理查找\"><a href=\"#3D紋理查找\" class=\"headerlink\" title=\"3D紋理查找\"></a>3D紋理查找</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|tex3D(s, t)|\t普通三維紋理查找 返迴紋理採樣器s在vector t位置的顏色<br>|tex3D(s,t,ddx,ddy)|\t使用微分查詢三維紋理， t和ddxy均為vector<br>|tex3Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4<br>|tex3Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的三維紋理查找<br>|tex3Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的三維紋理查找<br>|tex3Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢</p>\n<h1 id=\"立體紋理查找\"><a href=\"#立體紋理查找\" class=\"headerlink\" title=\"立體紋理查找\"></a>立體紋理查找</h1><p>| 函數名 | 用途<br>|——\t|——-<br>|texCUBE(s,t)|\t返迴紋理採樣器s在vector t位置的顏色<br>|texCUBE(s,t,ddx,ddy)|\t使用微分查詢立方體維紋理 ，t和ddxy均為vector<br>|texCUBEDload(s,t)|\t使用LOD查找紋理s在t.w位置的color4<br>|texCUBEbias(s,t)|\t將t.w決定的某個MIP層偏置後的立方體紋理查找<br>|texCUBEgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的立方體紋理查找<br>|texCUBEproj(s,t)|\t使用投影方式的立方體紋理查找</p>\n<h1 id=\"著色器導數函數\"><a href=\"#著色器導數函數\" class=\"headerlink\" title=\"著色器導數函數\"></a>著色器導數函數</h1><p>偏導數函數(偏差分導函數)（在HLSL和GLSL中）是片段著色器指令，可用於計算任何值相對於屏幕空間坐標的變化率</p>\n<p>偏導數函數是紋理mipmaps實現的基礎，也能實現一系列算法和效果，特別是哪些依賴於屏幕空間坐標的(比如渲染統一線寬的線框)。</p>\n<h1 id=\"導數計算-dFdx-和-dFdy-ddx-和-ddy\"><a href=\"#導數計算-dFdx-和-dFdy-ddx-和-ddy\" class=\"headerlink\" title=\"導數計算 dFdx 和 dFdy (ddx 和 ddy)\"></a>導數計算 dFdx 和 dFdy (ddx 和 ddy)</h1><p>在三角形光柵化期間，GPU 以 2×2 的 block 片段來計算光柵化，通過取block 中像素值之間的差異來計算導數</p>\n<h1 id=\"提高內容\"><a href=\"#提高內容\" class=\"headerlink\" title=\"提高內容\"></a>提高內容</h1><ol>\n<li>導數計算-續<details></li>\n</ol>\n<h1 id=\"導數計算-續\"><a href=\"#導數計算-續\" class=\"headerlink\" title=\"導數計算-續\"></a>導數計算-續</h1><ul>\n<li>dFdx 從右邊片段中減去左側片段像素值 (右 - 左)</li>\n<li>dFdy 從上邊片段中減去下部片段像素值 (上 - 下)</li>\n<li>下圖其中網格表示渲染的屏幕像素，以紅色突出顯示的 2×2 block 對應的(x, y)屏幕座標</li>\n</ul>\n<p><img src=\"/project/pic/Shader-Derivatives-1.png\"></p>\n<h1 id=\"示例代碼\"><a href=\"#示例代碼\" class=\"headerlink\" title=\"示例代碼\"></a>示例代碼</h1><p>在Unity中嘗試調用 tex2D ddx ddy 等函數，在&#x2F;Shader下ShaderOfDdx文件裡面有源碼</p>\n<pre class=\"line-numbers language-shaderlab\" data-language=\"shaderlab\"><code class=\"language-shaderlab\">Shader &quot;Custom&#x2F;ShaderOfDdx&quot;\n&#123;\n    Properties\n    &#123;\n        [KeywordEnum(IncreaseEdgeAdj, BrightEdgeAdj)] _EADJ(&quot;Edge Adj type&quot;, Float) &#x3D; 0\n        _Tex(&quot;Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n        _Intensity(&quot;Intensity&quot;, Range(0, 20)) &#x3D; 2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;\n            Cull off\n            Blend SrcAlpha OneMinusSrcAlpha\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #pragma multi_compile _EADJ_INCREASEEDGEADJ _EADJ_BRIGHTEDGEADJ\n            #include &quot;UnityCG.cginc&quot;\n            struct appdata\n            &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n            struct v2f\n            &#123;\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            &#125;;\n            sampler2D _Tex;\n            float4 _Tex_ST;\n            float _Intensity;\n            v2f vert (appdata v)\n            &#123;\n                v2f o;\n                o.vertex &#x3D; UnityObjectToClipPos(v.vertex);\n                o.uv &#x3D; TRANSFORM_TEX(v.uv, _Tex);\n                return o;\n            &#125;\n            fixed4 frag (v2f i, float f : VFACE) : SV_Target\n            &#123;\n                fixed a &#x3D; 1;\n                if (f &lt; 0) a &#x3D; 0.5;\n                fixed3 c &#x3D; tex2D(_Tex, i.uv).rgb;\n                #if _EADJ_INCREASEEDGEADJ &#x2F;&#x2F; 邊緣調整：增加邊緣差異調整\n                c +&#x3D; (ddx(c) + ddy(c)) * _Intensity;\n                #else &#x2F;&#x2F;_EADJ_BRIGHTEDGEADJ &#x2F;&#x2F; 邊緣調整：增加邊緣亮度調整\n                &#x2F;&#x2F;c +&#x3D; abs(ddx(c)) + abs(ddy(c)) *_Intensity;\n                c +&#x3D; fwidth(c) * _Intensity; &#x2F;&#x2F; fwidth(c) &#x3D;&#x3D;&gt; abs(ddx(c)) + abs(ddy(c))\n                #endif &#x2F;&#x2F; end _EADJ_INCREASEEDGEADJ\n                return fixed4(c, a);\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;</code></pre>\n\n<p><img src=\"/project/pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-31%20110539.png\"><br><img src=\"/project/pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-31%20110625.png\"><br><img src=\"/project/pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-31%20110659.png\"></p>\n<ul>\n<li>使用(ddx(c) + ddy(c))，沒有絕對值，會然邊緣的像素亮度差異變大，即：加強邊緣突出</li>\n<li>使用fwidth函數，可以看出邊緣變亮，突出邊緣 &#x2F;&#x2F; fwidth(c) &#x3D;&#x3D;&gt; abs(ddx(c)) + abs(ddy(c))</li>\n</ul>\n</details>\n\n<h1 id=\"課外練習\"><a href=\"#課外練習\" class=\"headerlink\" title=\"課外練習\"></a>課外練習</h1><ol>\n<li>嘗試在 Unity 中編寫 HLSL 代碼吧 (Unity Shaderlab)</li>\n<li>(提高) 試著了解著色器導數函數吧，看看這函數有甚麼奇淫技巧?</li>\n</ol>\n<h1 id=\"備忘\"><a href=\"#備忘\" class=\"headerlink\" title=\"備忘\"></a>備忘</h1><ul>\n<li><p><a href=\"https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions?redirectedfrom=MSDN\">hlsl-intrinsic-functions</a></p>\n</li>\n<li><p><a href=\"http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104\">shader-derivative-functions</a></p>\n</li>\n<li><p><a href=\"https://docs.microsoft.com/zh-cn/windows/desktop/direct3dhlsl/dx-graphics-hlsl-fwidth\">fwidth func in HLSL</a></p>\n</li>\n</ul>\n","feature":null,"text":"HLSL 入門和基本函數什麼是HLSL？ 高階著色器語言（High Level Shader Language，簡稱HLSL），就是用來編寫shader的一種語言 類似的語言還有： CG它是由NVIDIA公司所開發的，基於C語言同時被OpenGL和Direct3D所支持的開發語言...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"遊戲開發筆記","slug":"遊戲開發筆記","count":15,"path":"api/categories/遊戲開發筆記.json"}],"tags":[{"name":"Computer Graphic","slug":"Computer-Graphic","count":15,"path":"api/tags/Computer-Graphic.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HLSL-%E5%85%A5%E9%96%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">HLSL 入門和基本函數</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CG\"><span class=\"toc-text\">CG</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GLSL\"><span class=\"toc-text\">GLSL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HLSL\"><span class=\"toc-text\">HLSL</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B8%E5%88%86%E9%A1%9E\"><span class=\"toc-text\">常用函數分類</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B8%E5%AD%B8%E9%81%8B%E7%AE%97\"><span class=\"toc-text\">基本數學運算</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%AA%E6%8C%87%E5%B0%8D%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">冪指對函數</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A1%9E%E5%9E%8B%E5%88%A4%E6%96%B7%E9%A1%9E\"><span class=\"toc-text\">類型判斷類</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B8%E8%88%87%E9%9B%99%E6%9B%B2%E7%B7%9A%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">三角函數與雙曲線函數</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E8%88%87%E7%9F%A9%E9%99%A3%E9%A1%9E\"><span class=\"toc-text\">向量與矩陣類</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%89%E7%B7%9A%E9%81%8B%E7%AE%97%E9%A1%9E\"><span class=\"toc-text\">光線運算類</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B4%8B%E7%90%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">紋理查找</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1D%E7%B4%8B%E7%90%86%E6%9F%A5%E6%89%BE-%E5%B9%BE%E4%B9%8E%E4%B8%8D%E7%94%A8\"><span class=\"toc-text\">1D紋理查找 (幾乎不用)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2D%E7%B4%8B%E7%90%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">2D紋理查找</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3D%E7%B4%8B%E7%90%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">3D紋理查找</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E9%AB%94%E7%B4%8B%E7%90%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">立體紋理查找</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%91%97%E8%89%B2%E5%99%A8%E5%B0%8E%E6%95%B8%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">著色器導數函數</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8E%E6%95%B8%E8%A8%88%E7%AE%97-dFdx-%E5%92%8C-dFdy-ddx-%E5%92%8C-ddy\"><span class=\"toc-text\">導數計算 dFdx 和 dFdy (ddx 和 ddy)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8F%90%E9%AB%98%E5%85%A7%E5%AE%B9\"><span class=\"toc-text\">提高內容</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8E%E6%95%B8%E8%A8%88%E7%AE%97-%E7%BA%8C\"><span class=\"toc-text\">導數計算-續</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A2%BC\"><span class=\"toc-text\">示例代碼</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AA%B2%E5%A4%96%E7%B7%B4%E7%BF%92\"><span class=\"toc-text\">課外練習</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%82%99%E5%BF%98\"><span class=\"toc-text\">備忘</span></a></li></ol>","author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}},"mapped":true,"prev_post":{"title":"模型格式和材質","uid":"9969c9a42c025437ce5d231d56edb863","slug":"GraphicQuest/GQ002 模型格式和材質","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T14:57:29.305Z","comments":true,"path":"api/articles/GraphicQuest/GQ002 模型格式和材質.json","keywords":null,"cover":"https://cdn.discordapp.com/attachments/1032335453988335676/1041569155167567872/IMG_20221114_114537.jpg","text":"GQ002 模型格式和材質OBJ文件OBJ文件是一種被廣泛使用的3D模型文件格式（obj為後綴名）。由Alias|Wavefront公司為3D建模和動畫軟件”Advanced Visualizer”開發的一種標準，適合用於3D軟件模型之間的互導，也可以通過3dsmax、Maya等...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"遊戲開發筆記","slug":"遊戲開發筆記","count":15,"path":"api/categories/遊戲開發筆記.json"}],"tags":[{"name":"Computer Graphic","slug":"Computer-Graphic","count":15,"path":"api/tags/Computer-Graphic.json"}],"author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}},"feature":null},"next_post":{"title":"傳統光照模型詳解","uid":"a993952f98b295ed6db3d1a544a2ca1d","slug":"GraphicQuest/GQ004 傳統光照模型詳解","date":"2022-12-14T14:00:28.000Z","updated":"2022-12-14T14:56:51.710Z","comments":true,"path":"api/articles/GraphicQuest/GQ004 傳統光照模型詳解.json","keywords":null,"cover":"https://cdn.discordapp.com/attachments/1032335453988335676/1042735649947656212/FQN1S51VgAMsSZa.jpg","text":"傳統光照模型詳解光照模型分類: 基於物理的光照模型（PBR）（有可依據的公式） 經驗模型（近似、模擬） 局部光照的定義:只考慮光源的影響，不考慮光線多次反射 （對應的概念：全局光照&#x3D;直接光照+間接光照） 局部光照模型內容的分類: 局部光照模型滿足疊加原理，可分為四個部分...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"遊戲開發筆記","slug":"遊戲開發筆記","count":15,"path":"api/categories/遊戲開發筆記.json"}],"tags":[{"name":"Computer Graphic","slug":"Computer-Graphic","count":15,"path":"api/tags/Computer-Graphic.json"}],"author":{"name":"tom_ci","slug":"blog-author","avatar":"https://cdn.discordapp.com/attachments/894788659356794880/1052779378314059846/AOh14GhDhRBs5Io0sk5AfsOAZLWzpaTSlQQbTaye9fiGhQs432-p-rw-no.png","link":"/","description":"tom_ci，也可以叫我CI，tom，ic，湯姆希艾或者是湯姆，艾希，Macau SMP現任群主。","socials":{"github":"https://github.com/tom-choi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/Ua2njAfQCN"}}}},"feature":null}}