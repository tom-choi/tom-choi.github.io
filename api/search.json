[{"id":"d077cfc7cff1c8d96163d0d9b446e8a6","title":"高級著色 BRDF 及相關技術","content":"高級著色 BRDF 及相關技術\n\n\n\n\n\n\n\n\nPhysically-Based Materials (Surface models) BRDF 基於物理的材質\n\n\n\n\n\n\n\n\n\n想像你有一個不透明的桌面，一個激光發射器。你先讓激光向下垂直地射在那個桌面上，這樣你就可以在桌面上看到一個亮點，接著你從各個不同的方向來觀察那個亮點，你會發現亮點的亮度隨著觀察方向的不同而發生了改變。然後你站著不動，改變激光發射方向和桌面的夾角，你又會發現亮點的亮度發生了改變。這就是說，一個表面對不同的光線入射角和反射角的組合，擁有不同的反射率。 BRDF就是用來對這種反射性質進行定義的。 – 大饼土博​\nBRDF 前置-數學球座標系 spherical coordinate system快速了解\n球坐標標記為 ${(r,\\ \\theta ,\\ \\varphi )}$，其中:\n\n$r$ 代表徑向距離\n$\\theta$ 代表極角，表示向量和Z軸的夾角\n$\\varphi$ 代表方位角，表示向量在x-y平面上的投影和x軸的逆時針夾角。\n\nBRDF 前置-輻射度量學\n\n物體發射的光流量+流入物體的光流量&#x3D;直接流量+反射流量+吸收流量\n光流量是單位時間通過單位面積的能量\n光亮度是物體表面某方向單位投影區域單位立體角的光流量\n沿著某條光線的光亮度是常數，但光通量隨距離增大而衰減（實際是二次衰減，但在計算機圖形學中採用線性衰減效果比較好）\n光強度是單位立體角的輻射能量\n輻射度是單位面積流出的光通量\n輻照度是單位面積流入的光通量\n它們的關係：\n光強度&#x3D;光亮度單位面積入射角餘弦\n輻照度&#x3D;光亮度入射角餘弦單位立體角\n輻射度&#x3D;光亮度入射角餘弦單位立體角（但方向不同）\nBRDF規定的是輻照度和光亮度的關係：\n光亮度&#x3D;BRDF*輻照度\n\n\nBRDF 定義BRDF 種類\nMicrofacet BRDF(微表面模型)\nDisney Principled BRDF\n\n其他的BRDF","slug":"GraphicQuest/GQ014 實時渲染5 高級著色 BRDF及相關技術","date":"2022-12-15T02:51:05.883Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"fe78cfdcfa53a2e96639cd6436845377","title":"紋理(材質)的構成","content":"GQ001 紋理(材質)的構成紋理(材質)是甚麼?本質上就是一張圖片\n\n一種可以讓著色器讀寫的結構化存取形式\nImage [Height] [Width] [4]\nT [512][512][4]\nRGBA\n\n紋理管線 (通常使用的架構)\n模型空間位置 -&gt; 投影函數\n\n紋理映射 -&gt; 紋理座標 (UV座標)\n\n通訊函數 -&gt; 新紋理座標\n\n紋理採樣 (Sampler, 避免依賴紋理讀取) -&gt; 紋理值\n\n\n\nUV值，UV座標對於三維模型，有兩個最重要的坐標系統，一是頂點的位置（X，Y，Z）坐標，另一個就是UV坐標。\n什麼是UV？簡單的說，就是貼圖影射到模型表面的依據。完整的說，其實應該是UVW（因為XYZ已經用過了，所以另選三個字母表示）。\nU和V分別是圖片在顯示器水平、垂直方向上的坐標，取值一般都是0~1，也 就是（水平方向的第U個像素&#x2F;圖片寬度，垂直方向的第V個像素&#x2F;圖片高度）。\n那W呢？貼圖是二維的，何來三個坐標？W的方向垂直於顯示器表面，一般 用於程序貼圖或者某些3D貼圖技術（記住，確實有三維貼圖這種概念！），對於遊戲而言不常用到，所以一般我們就簡稱UV了。\n圖片文件都是二維方向上的平面。我們設水平方向是U，垂直方向是V，我們可以定位圖像上的任意一個像素。注意的是，(u,v)值範圍為[0,1]\nUV就是將圖像上每一個點精確對應到模型物體的表面，在點與點之間的間隙位置進行圖像光滑插值處理，這就是所謂的UV貼圖。\n對於NURBUS表面。因為具有UV參數，所以很容易通過換算把表面上的點和平面圖像上的像素對應起來。\nNURBUS?有興趣可以了解一下貝茲曲線，樣條先再入手\n\n\n非均勻有理B樣條\n三次方貝茲曲線的[[參數方程|參數]]形式：\n$$\\mathbf{B}(t)&#x3D;\\mathbf{P}_0(1-t)^3+3\\mathbf{P}_1t(1-t)^2+3\\mathbf{P}_2t^2(1-t)+\\mathbf{P}_3t^3, t \\in [0,1]$$\n\n\n例子假設我們知道在模型空間位置需要渲染的點為 (-2.3,7.1,88.2)，經過投影函數的變換之後，我們會獲得一個uv值 (u,v)，換算回來就是 (0.32,0.29) 紋理座標 (UV座標)\n已知紋理的大小為 256 * 256，我們把uv座標相乘256，獲得 (81.92,74.24)，紋理採樣設置則決定了此紋理值rgba值 (可自定義)\n\n通訊函數使圖像可以平移，縮放，旋轉\n紋理採樣\n著色器中紋理通常以SamplerVariable（採樣變量）的形式存在，它是一種uniform型變量，在處理不同片元時，它是已知不變的；\n一個Sample與一個Texture對應，是一種特殊變量。如果是二維紋理時，則為Sampler2D；\n\n紋理採樣設置: Wrap Mode決定UV值在[0,1]以外的表現\n\nOpenGL — “包裝模式” (Wrapping Model)\nDirectX — “紋理尋址模式” (Texture Addressing Mode)\nRepeat Mirror Clamp Broder\n\n紋理採樣設置: Filter Mode (過濾設置)決定了當紋理由於變化而產生拉伸的時候，要採用哪一種濾波模式來調整它的表現\n\n雙線性插值\n立方卷積插值\nQu‘ilez的光滑曲線插值\n\n\n提高內容\n雙線性插值: 詳細推導過程\n紋理採樣 (過濾設置)\n\n首先在 ‘’x’’ 方向進行線性插值，得到\n$$\\begin{align}f(x, y_1) &amp;\\approx \\frac{x_2-x}{x_2-x_1} f(Q_{11}) + \\frac{x-x_1}{x_2-x_1} f(Q_{21}), \\f(x, y_2) &amp;\\approx \\frac{x_2-x}{x_2-x_1} f(Q_{12}) + \\frac{x-x_1}{x_2-x_1} f(Q_{22}).\\end{align}$$\n然後在 ‘’y’’ 方向進行線性插值，得到\n$$\\begin{align}f(x,y) &amp;\\approx \\frac{y_2-y}{y_2-y_1} f(x, y_1) + \\frac{y-y_1}{y_2-y_1} f(x, y_2) \\&amp;&#x3D; \\frac{y_2-y}{y_2-y_1} \\left ( \\frac{x_2-x}{x_2-x_1} f(Q_{11}) + \\frac{x-x_1}{x_2-x_1} f(Q_{21}) \\right ) + \\frac{y-y_1}{y_2-y_1} \\left ( \\frac{x_2-x}{x_2-x_1} f(Q_{12}) + \\frac{x-x_1}{x_2-x_1} f(Q_{22}) \\right ) \\&amp;&#x3D; \\frac{1}{(x_2-x_1)(y_2-y_1)} \\big( f(Q_{11})(x_2-x)(y_2-y) + f(Q_{21})(x-x_1)(y_2-y)+  f(Q_{12})(x_2-x)(y-y_1) + f(Q_{22})(x-x_1)(y-y_1) \\big)\\&amp;&#x3D;\\frac{1}{(x_2-x_1)(y_2-y_1)}  \\begin{bmatrix} x_2-x &amp; x-x_1 \\end{bmatrix} \\begin{bmatrix} f(Q_{11}) &amp; f(Q_{12}) \\ f(Q_{21})&amp; f(Q_{22}) \\end{bmatrix} \\begin{bmatrix}y_2-y \\ y-y_1 \\end{bmatrix}.\\end{align}$$\n注意此處如果先在 ‘’y’’ 方向插值、再在 ‘’x’’ 方向插值，其結果與按照上述順序雙線性插值的結果是一樣的。\n例子已知: 點P(u,v) &#x3D; (81.92,74.24)\n\n點P(u,v) 減去 像素中心 (0.5,0.5) &#x3D; (81.42,73.74)\n取得最接近的四個屏幕像素點範圍: (81,73) ~ (82,74)\n相對於該四個像素中心形成的座標系位置 (u,v) &#x3D; (0.42,0.74)\n\n$$f(x,y) \\approx \\begin{bmatrix}1-x &amp; x \\end{bmatrix} \\begin{bmatrix}f(0,0) &amp; f(0,1) \\f(1,0) &amp; f(1,1) \\end{bmatrix} \\begin{bmatrix}1-y \\y \\end{bmatrix}$$\n插值顏色&#x3D; $(1-0.42)×(1-0.74)t(x,y)+0.42(1-0.74)×t(x+1,y)+(1-0.42)0.74t(x,y+1)+0.42×0.74×t(x+1,y+1)$\n立方卷積插值 和 Qu‘ilez的光滑曲線插值自己上網找找看看\nMipmapping在C++ DirectX中 LV201-Mipmapping 可以學習\nAnisotropic Filtering 各向異性過濾在C++ DirectX中 LV201-Anisotropic Filtering 可以學習\n積分圖 summed area table以內存為代價，更加有效地計算紋理值。例如將數組中的R8G8B8A8 轉成 R16G16B16A16，再代入公式\n\n\n紋理的優化和應用CPU渲染優化的方式：\n\n紋理圖集 (將多張紋理合併到一張紋理中，降低頻繁改變紋理所帶來的消耗)\n紋理數組\n無約束紋理\n紋理壓縮：減小紋理的體積\n\n\nDrawCall為使CPU和GPU並行工作，存在一個命令緩衝區來存儲命令隊列。 CPU向其中添加命令，GPU從其中讀取命令。 DrawCall是命令的一種。如果DrawCall過多，則CPU將花費大量時間在提交DrawCall上。\n其他常見紋理\n立方體紋理（CubeMap）：使用六張貼圖形成以原點為中心的立方體。採樣時使用方向向量，從原點出發的方向向量與立方體相交的位置即為採樣點。一般應用於環境貼圖。\n\n凹凸貼圖（BumpMap）：在不增加頂點、不移動頂點的情況下，改變模型法線，產生凹凸效果。\n\n位移貼圖（Displacement Mapping）：將頂點進行移動，產生凹凸效果。這要求模型表面有足夠多的頂點供使用。 DirectX提供了一種動態進行曲面細分的方法，使得在模型本身頂點數量較少的情況下，仍能正確使用位移貼圖。\n\n\n備忘錄Unreal Engine 5 自定義UVhttps://docs.unrealengine.com/5.0/zh-CN/customized-uvs-in-unreal-engine-materials/\n","slug":"GraphicQuest/GQ001 材質的構成","date":"2022-12-14T15:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"2286370fa348f66aebd7d5e4beef2d8d","title":"遊戲編程筆記 前言","content":"前言\n\n\n\n\n\n\n\n\n我們所有的夢想都可以真的，只要我們有勇氣去追求它們（All our dreams can come true, if we have the courage to pursue them）。———— 華特·迪士尼\n遊戲編程筆記個人學習遊戲編程，收錄於CPSStudyClub，以後可能再整理一下倉庫內的目錄\n——⚠️施工中的文章⚠️——\n美術篇\n美術理論基礎\n角色設計簡介\n場景設計簡介\n模型基礎和設計\n\n\n計算機圖形學筆記\n深度與模板測試\n\n\n計算機圖形學筆記 - 實時渲染篇 \n實時渲染4 3D空間GI的LPV算法和VXGI算法 SSAO算法\n實時渲染5 高級著色 BRDF及相關技術\n\n\nC++ 雜項 筆記\n速通LeetCode水題一百道\n\n\n\n值得一看的b站影片\nGAMES-Webinar b站主頁\n一個關於研究計算機圖形學組織，內有大量圖形學，每星期有研討會，包含大量關於學術界和工業界前沿知識講授。\nGAMES101, GAMES202, GAMES104 都是很優質的系列!\n\n\nCSAPP-深入理解计算机系统\n源於書本 - 深入理解计算机系统，不論是中文和英文都難以理解，這裡有高質量動畫影片能通俗易懂計算機原理\n\n\n\n值得一看的YT影片\nC++ 3D DirectX 11 Tutorial\n由ChiliTomatoNoodle發佈的C++ 3D DirectX 11教學，一個很硬核的教學系列，內含主要為DirectX 11 API和軟件工程等知識，學習前需要了解基本的圖形學數學知識和使用github等技巧，Chili也在Discord活躍中，在c++領域中也有許多相關影片\n\n\nVol 036 如何设计一个逼真的三维模型 | 回形针\n內有計算機圖形學中著名的貝塞爾曲線和B樣條\n\n\n\n值得一看的知乎專題和文章系列\n《DirectX12 3D游戏开发实战》\nDirectX12 圖形api 教學筆記\n\n\n实时渲染GI｜Directional Occlusion：SSDO\n環境光吸收質量，一種為相互靠近的物體增加柔和的陰影，極大地提升高圖像質量\n\n\n浅谈卡通渲染与真实感渲染结合思路\n“三渲二” 技術導讀，很好的科普文章\n\n\nUE5渲染技术简介：Nanite篇\n在GAMES104前沿技術課上有提及，目前還沒有看懂\n\n\nGAMES104《现代游戏引擎：从入门到实践》视频公开课文字实录\nGAMES104 文字實錄，想要節省流量只看文字版可以看這個\n\n\n\n值得一看的Github倉庫&#x2F;論文\nGame-Programmer-Study-Notes\n遊戲程序員毛星雲一生生涯的讀書筆記合輯\n\n\n图形学论文实现\n論文 + 代碼，助你更好理解圖形學\n\n\nHigh-Resolution Image Synthesis with Latent Diffusion Models\nDiffusion Models 開山論文，近期很火的NovelAI(AI畫畫)中也有相關模型\n\n\n\n值得一看的書\n《Real–time Rendering 3rd》\n《Real–time Rendering 4th》\n《GPU Gems 1 》\n《GPU Gems 2 》\n《GPU Gems 3 》\n《Game Engine Architecture》\n\n倉庫目錄\n計算機圖形學 筆記:\n材質的構成\n模型格式和材質\nHLSL入門和基本函數\n傳統光照模型詳解\nGamma校正和色彩空間\nLDR和HDR\n材質和外觀\n相機與透鏡\n實現Flowmap\n\n\n計算機圖形學筆記 - 實時渲染篇 (Real–time Rendering)\n實時渲染1_Shadow Mapping、PCSS、VSSM、SDF Shadows\n實時渲染2 延遲渲染 Deferred Rendering\n實時渲染3 實時環境光照：Split Sum、PRT\n實時渲染4 3D空間GI的LPV算法和VXGI算法 SSAO算法\n實時渲染5 高級著色 BRDF及相關技術\n\n\nC++ DirectX 11 筆記 (源於Chili架構):\nMipmapping\nAnisotropic Filtering\nAlpha Compositing\nZtest\nCD3D11\n\n\nUnity 筆記 (青春版):\nUnity簡介\nUnity介面\nUnity_CCShader\nUnity Shader\nLambert光照模型\n\n\nC++ WindowsAPI 筆記 (源於Chili架構):\n創建WinMain\n更多WinMain資料\n創建一個窗口\n\n\nC++ 雜項 筆記:\ni++和++i哪個快\n神寄的ASCII碼\n基於複製的瞬間移動\nCOM架構\n速通LeetCode水題一百道\n\n\n遊戲開發工具包: \n免費／付費美術資源地址整合\n\n\n\n\n遊戲編程?遊戲編程這個方向看似很明確，其實並不然。製作一款遊戲可以不用學會編程語言，甚至是可以離開電腦。我們回歸到人類原始的遊戲類型桌遊，我們對這各個類型不一的紙牌也能玩的很開心，精美的卡片，多變的規則，複雜的人心，公正的主持，都是遊戲的主要構成元素，在此之上，當我們學習如何製作一款”桌遊”的規則時，我們也就成為了所謂的”Gameplay Programmer” 遊戲邏輯程序員，他們就是在遊戲世界制定所有秩序之神————忒彌斯\n那麼創造這個遊戲世界大地之神是誰?當然是我們的 “Game Engine Programmer” 遊戲引擎程序員，比起掌握所有的規則，掌握了遊戲引擎更像是掌握這片遊戲世界的核心，比起天馬行空的遊戲策劃，他們更願意去腳踏實地做好遊戲裡的每一片細節，以致於他們在遊戲開發組裡是不常被提起的一幫人。絕大多數初創遊戲公司想進一步擴大業務的時候，都一定需要一名蓋亞來協助他們的工作，所以學習遊戲引擎具有極高的價值。\n做哪種程序員?一般來說，想成為遊戲邏輯程序員只需要學習入門划時代的遊戲引擎就可以了，比如可以學習使用虛幻4,虛幻5,Unity這種主流的遊戲引擎，但是對電腦設備要求比較高，而且對於新人程序員來說，學習上手任一款遊戲引擎的難度都是差不多的，在對比如使用c++語言的UE4,UE5和使用c#語言的unity來說，如果僅僅學習過c++語言和c#語言基本語法以及都沒有上手項目的經驗，可以說你對遊戲引擎裡編程語言起步點為0，學習哪一個遊戲引擎都是一樣的。\n但是使用遊戲引擎畢竟是停留在表面看不到本質，當遊戲開發的時候出現了某些問題或者特殊需求，你往往很難處理。而且遊戲引擎技術日新月異，你所學的幾乎都是別人留下來的方法，而不是其本質思想。如果將來別的遊戲引擎興起，你又要重新學習另外的遊戲引擎怎麼使用。在很多大公司裡面，甚至都有自己公司內部專用的引擎（如網易公司的風魂引擎、金山公司的劍網3引擎、蝸牛公司的Flexi引擎等等）。所以單純地走這條路線，可能不會讓你走得很遠並且可能會日漸乏味。\n深入學習遊戲引擎原理短時間不會讓你的工作有什麼卓越的成效，但是可以彌補只使用遊戲引擎導致的問題，而且學習遊戲引擎原理，更多時候不是一定就為了自己日後要造個遊戲引擎，而是更深入理解自己的遊戲引擎，更好地使用它。當然，千里之行始於足下，經常學習遊戲引擎底層原理的人到了一定的積累的時候，自己造個遊戲引擎也是可以的。對於像學習遊戲引擎原理的人來說，需要製定自己明確的長期目標：\n\n首先，一開始可能對遊戲引擎沒什麼概念，建議還是先使用一兩個遊戲引擎（推薦可以學習虛幻4,虛幻5遊戲引擎，所有免費開源的遊戲引擎都非常值得學習。）\n\n因為遊戲開發就是一門實時渲染的藝術，所以離不開圖形庫的學習。現在主流的圖形庫是Windows平台專用的DirectX 11和通用平台的Opengl。這兩個圖形庫，至少需要入門其中一個。經實測，入門DirectX 11過程比入門Opengl難上很多，如果想要學習更高端的軟件工程中設計原理以及c++中的智慧型指針等可以選擇\n\n然後，你就可以開始看計算機圖形學的書籍了。如果你發現你的理論底子不足，這個時候就需要補一下線性代數、基本的微積分、還有3D數學的知識(內容難但不多)。\n\n遊戲引擎中包含了各個部分，上面的渲染只是遊戲引擎的一部分。還有其它諸如著色器編寫、地形編寫、物理引擎編寫、模型和動畫、人工智能(AI)設計、網絡編程等等，完成渲染部分的基本學習後，你可以選擇自己感興趣的部分進行專攻，畢竟我們實際工作大多數時候是團隊開發，而不是單打獨鬥，每個人都應該精通自己所擅長的那部分。\n\n\n在不少的編程語言都會視其為一個項目，如貪食蛇小遊戲，俄羅斯方塊等，但這並不是我們想要在2022年玩到的遊戲。在划時代的技術下，我們更多的依賴各式各樣硬件加速技術和軟件工程技術去製作一款遊戲。\n\n備忘錄\n\n\n\n\n\n\n\n\n部分內容來自於知乎\n","slug":"README","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"C/C++,Unity,Computer Graphic","author_index":"tom_ci"},{"id":"e01cf34c5024afe8c744ed5dbe78b0b8","title":"實時渲染 3D空間GI的LPV算法和VXGI算法 SSAO算法","content":"實時渲染 3D空間GI的LPV算法和VXGI算法 SSAO算法全局光照，(Global Illumination,簡稱 GI)或被稱為Indirect Illumination, 間接光照，是指既考慮場景中直接來自光源的光照（Direct Light）又考慮經過場景中其他物體反射後的光照（Indirect Light）的一種渲染技術。使用全局光照能夠有效地增強場景的真實感。\n即可以理解為：全局光照 &#x3D; 直接光照(Direct Light) + 間接光照(Indirect Light)\nLight Propagation Volumes （LPV）LPV: 在3D空間中去傳播光線,從而利用它做出間接光照從而實現GI.\nVXGI算法SSAO算法SSDO算法","slug":"GraphicQuest/GQ013 實時渲染4 3D空間GI的LPV算法和VXGI算法 SSAO算法","date":"2022-12-15T02:51:05.879Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"a200d86f4537c56fcd6e406543954493","title":"實時環境光照：環境光照與預計算 環境光與Split Sum、PRT","content":"實時環境光照：環境光照與預計算 環境光與Split Sum、PRT1 環境映射 Environment Mapping在《Real-Time Rendering 3rd》第八章 : Area and Environmental Lighting 中，介紹了 Environment Mapping (環境映射)\nEnvironment mapping（環境映射），又稱Reflection Mapping（反射映射）,是計算機圖形學領域中使用基於圖像的光照（Image-Based Lighting，IBL）技術，用預先計算的紋理圖像模擬複雜鏡面的一種高效方法。\n環境映射將周圍環境與光照通過直接投影而簡化表示為紋理，保存的環境光照在繪製時假設來自無窮遠處，得到的環境光照圖常是球體圖（spherical map）或立方體圖（cube map）。\n球體圖（spherical map）及立方體圖（cube map）示意 圖源：[GAMES202 閆令琪]\n由於是事先準備好的數據，這種實現方法比傳統的光線跟踪算法效率更高，但是需要注意的是這種方法是實際反射的一種近似，有時甚至是非常粗糙的近似。這種技術的一個典型的缺點是沒有考慮自反射，即無法看到物體反射的物體自身的某一部分。\n1.1 IBL（Image-Based Lighting）IBL（Image-Based Lighting）是指根據環境光照圖，在不考慮可見性 V(p,ωi) 的條件下直接著色給定點 p 的技術，相應的繪製方程如下：\n$$\\begin{align} L_o \\left( p ,, \\omega_o \\right)  &amp;&#x3D; \\int_{\\Omega^{+}} L_{i} \\left( p ,, \\omega_i \\right) f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i \\cancel{ V\\left(p,,\\omega_i\\right) } \\mathrm{d}\\omega_i \\end{align} \\$$\n為了求解繪製積分，可以使用蒙特卡羅方法抽樣環境光入射方向進行近似，但是為了讓蒙特卡羅方法收斂，可能需要抽樣大量的環境光入射方向樣本，這將耗費大量的計算資源，\n2 The Split Sum Approximation簡單理解:\n\n放棄原渲染方程的visibility項\n著色點的lighting項就變成了環境光的lighting\n\n在實時渲染中存在如下重要的估算定積分方法，將兩個函數乘積的定積分拆解成兩個函數定積分的乘積：\n$$\\begin{align}\\int_{\\Omega} f(x) g(x), \\mathrm{d}x\\end{align}$$\n$$\\begin{align}\\approx \\frac{\\int_{\\Omega} f(x),\\mathrm{d}x}{\\int_{\\Omega}\\mathrm{d}x} \\cdot \\int_{\\Omega} g(x),\\mathrm{d}x \\\\end{align}$$\n\n假如被積函數較為平滑（例如漫反射材質的 BRDF），或者支撐集較小（例如光源相對不多時直接採樣光源所用的可見性函數），則在實時渲染中認為該估計基本成立；\n\n為了避免抽樣估計定積分，分離求和方法（The Split Sum）認為 BRDF 在求解定積分時可以被拆解出來，於是繪製方程變成瞭如下形式：\n$$\\begin{align} L_o \\left( p ,, \\omega_o \\right) &amp;&#x3D; \\int_{\\Omega^{+}} L_{i} \\left( p ,, \\omega_i \\right) f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i \\mathrm{d}\\omega_i \\ &amp;\\approx \\frac{\\int_{\\Omega^{+}} L_{i} \\left( p ,, \\omega_i \\right) , \\mathrm{d} \\omega_i }{\\int_{\\Omega^{+}}\\mathrm{d}\\omega_i } \\int_{\\Omega^{+}}  f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i \\mathrm{d}\\omega_i \\end{align} \\$$\n漫反射材質 BRDF 較為平滑，而對於那些不怎麼平滑的有光澤材質 BRDF，支撐集又一般較小，於是可以得到不錯的近似結果。\n另外，該方法之所以被稱為拆解求和（split sum）而不是拆解積分，是因為方法的提出者把積分寫成了求和形式\n$$\\frac{1}{N} \\sum_{k&#x3D;1}^{N} \\frac{  L_{i} \\left( p ,, \\omega_i \\right) f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i }{ \\mathrm{pdf}\\left( p ,, w_i\\right) } \\approx \\left( \\frac{1}{N} \\sum_{k&#x3D;1}^{N}  L_{i} \\left( p ,, \\omega_i \\right) \\right) \\left( \\frac{1}{N} \\sum_{k&#x3D;1}^{N} \\frac{ f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i }{ \\mathrm{pdf}\\left( p ,, w_i\\right) } \\right) \\$$\n2.1 The Split Sum 第一部分積分我們先來處理這一部分的積分: $\\frac{\\int_{\\Omega^{+}} L_{i} \\left( p ,, \\omega_i \\right),\\mathrm{d}\\omega_i }{\\int_{\\Omega^{+}} \\mathrm{d}\\omega_i }$\n$\\frac{\\int_{\\Omega^{+}} L_{i} \\left( p ,, \\omega_i \\right),\\mathrm{d}\\omega_i }{\\int_{\\Omega^{+}} \\mathrm{d}\\omega_i }$，它相當於對環境光照圖施加了均值濾波，而濾波卷積核的尺寸取決於 BRDF 的支撐集。\n於是，當著色給定點時，根據理想鏡面反射方向查詢預濾波後的環境光照圖，就相當於同時查詢了以理想鏡面反射方向為中心的區域內的環境光照，便不需要抽樣了\n查詢一次濾波後結果，相當於查詢多次沒有濾波的結果 圖源：[GAMES202 閆令琪]\n\n不同尺寸的濾波卷積核，預計算環境光照圖的圖像金字塔(mipmap)；在著色時，根據 BRDF 得到合適的濾波卷積核的尺寸，可以方便地從相應的層級或通過三線性插值得到環境光\n使用不同尺寸的濾波卷積核預計算 MIPMAP 圖源：[GAMES202 閆令琪]\n\n2.2 The Split Sum 第二部分積分第二部分的積分: $\\int_{\\Omega^{+}}  f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i \\mathrm{d}\\omega_i$\n可以根據所有可能的參數進行預計算，或者使用 LTC 方法（Linearly Transformed Cosines）。\n對於微表面模型的 BRDF，可以對菲涅爾項使用石里克近似（Schlick’s approximation）\n$$F\\left(\\theta\\right) &#x3D; R_0 + \\left(1-R_0\\right) \\left(1-\\cos\\theta\\right)^5 \\$$\n\n$R_0 &#x3D; \\left( \\frac{\\eta_1 - \\eta_2}{\\eta_1 + \\eta_2} \\right)^2$ 是基底顏色，其中 $\\eta_1$ 和 $\\eta_2$ 是著色點所處表面兩側介質的折射率；\n在實時渲染中，著色點出光線的入射角 $\\theta_i$、出射角 $\\theta_o$ 及兩者的半角被認為非常接近，於是此處簡單地用 $\\theta$ 描述光線方向\n\n然後，後一部分的定積分可以根據菲涅爾項進行拆解：\n$$\\begin{align} \\int_{\\Omega^{+}}  f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i \\mathrm{d}\\omega_i\\end{align}$$\n$$\\begin{align}\\approx \\int_{\\Omega^{+}}  \\frac{f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right)}{F\\left(\\theta_i\\right)} \\left[ R_0 + \\left(1-R_0\\right) \\left(1-\\cos\\theta_i\\right)^5 \\right] \\cos\\theta_i \\mathrm{d}\\omega_i\\end{align}$$\n$$\\begin{align} &amp;&#x3D;  R_0 \\int_{\\Omega^{+}}  \\frac{f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right)}{F\\left(\\theta_i\\right)} \\left[ 1 - \\left(1-\\cos\\theta_i\\right)^5 \\right] \\cos\\theta_i \\mathrm{d}\\omega_i + \\int_{\\Omega^{+}}  \\frac{f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right)}{F\\left(\\theta_i\\right)}  \\left(1-\\cos\\theta_i\\right)^5  \\cos\\theta_i  \\mathrm{d}\\omega_i \\end{align}$$\n於是定積分不再依賴於基底顏色 R0，在預計算 $\\frac{f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right)}{ F\\left(\\theta\\right)}$ 時只需要考慮粗糙程度和入射角的餘弦即可。\n2.3 甚麼是 LTC 方法（Linearly Transformed Cosines）?2.4 甚麼是 石里克近似（Schlick’s approximation）?3 環境光照陰影假如在著色時需要考慮環境光的可見性，則實現實時渲染是一個相當困難的問題。\n$$\\underset{ \\text{給定點 $p$ 的著色給果} }{ \\underbrace{ L_o \\left( p ,, \\omega_o \\right) } } &#x3D; \\int_{\\Omega^{+}}  \\underset{ \\text{環境光照} }{ \\underbrace{ L_{i} \\left( p ,,\\omega_i \\right)  } } \\cdot \\underset{ \\text{ BRDF} }{ \\underbrace{ f_{r}\\left(  p ,,\\omega_i ,, \\omega_o \\right)  \\cos\\theta_i  } } \\cdot \\underset{ \\text{可見性} }{ \\underbrace{ V\\left(p ,,\\omega_i\\right)   } }  \\mathrm{d}\\omega_i \\$$\n\n因為環境光照來自四面八方，所以如果把環境光照下的著色看作多光繪製（many-light rendering），則每一個光源都要生成一張陰影圖，那麼陰影圖的數量將極其龐大；\n如果把該問題看作抽樣問題，則環境光照的可見性項 $V$ 可能是任意複雜度，不能根據 split sum 方法估計積分結果；\n因為 $L_i\\left(p ,, \\omega_o\\right)$ 的支撐集是整個半球，而 BRDF $f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right)$ 可能並不平滑，於是 拆解出 $V$ 後，餘下的 $L_{i} \\left( p ,, \\omega_i \\right) f_{r}\\left( p ,, \\omega_i ,, \\omega_o \\right) \\cos\\theta_i$ 支撐集並不小，也可能並不平滑；\n\n目前，工業界的一般方案是選取環境中最亮的那個光源（例如太陽）或前幾個光源生成陰影圖，然後由此生成陰影，而學術界的一些相關研究如下：\n\nimperfect shadow maps；\nlightcuts；\nRTRT（real time ray tracing），可能是終極解決方案；\nPRT（precomputed radiance transfer）；\n\n4 PRT（Precomputed Radiance Transfer，預計算輻射亮度傳輸）PRT（precomputed radiance transfer，預計算輻射亮度傳輸）的核心思想是假設場景中的只有光照會發生變化，將繪製方程的被積函數拆分成光照（lighting）和光線傳輸（light transport）這兩部分，並分別預計算兩者的紋理圖像，再把圖像從空間域轉換到頻域，最終把著色時繪製方程中的定積分計算轉換成向量的點積，或者轉換成向量與矩陣的乘法。\nPRT 效果示意 圖源：[GAMES202 閆令琪]\n4.1 預計算光照（Lighting）和光線傳輸（Light transport）PRT 將繪製方程的被積函數拆分成光照（lighting）和光線傳輸（light transport）這兩部分，分別預計算而得到兩張紋理圖像：\n$$\\begin{align} \\underset{ \\text{給定點的著色結果} }{ \\underbrace{ L_o \\left( \\omega_i \\right) } } &amp;&#x3D; \\int_{\\Omega^{+}}  \\underset{ \\text{光照} }{ \\underbrace{ L_{i} \\left( \\omega_i \\right)  } } \\cdot \\underset{ \\text{ BRDF} }{ \\underbrace{ f_{r}\\left(  \\omega_i ,, \\omega_o \\right)  \\cos\\theta_i  } } \\cdot \\underset{ \\text{可見性} }{ \\underbrace{ V\\left(\\omega_i\\right)   } }  \\mathrm{d}\\omega_i\\end{align}$$\n$$\\begin{align}&amp;&#x3D; \\int_{\\Omega^{+}}  \\underset{ \\text{光照} }{ \\underbrace{ L_{i} \\left( \\omega_i \\right)  } } \\cdot \\underset{ \\text{光線傳輸，記作 } T\\left(\\omega_i ,, \\omega_o \\right) }{ \\underbrace{ f_{r}\\left( \\omega_i ,, \\omega_o \\right)  \\cos\\theta_i V\\left(\\omega_i\\right)   } }  \\mathrm{d}\\omega_i \\end{align}$$\n然後，把這兩個在空間域的圖像信號變換到頻域，表示成基本信號 $B_{i}\\left(\\omega_i\\right)$ 的線性組合：\n$$\\begin{align} L_{i} \\left( \\omega_i \\right) &amp;&#x3D; \\sum_{p} \\underset{ \\text{光照系數} }{ \\underbrace{ l_p }} \\cdot \\underset{ \\text{基函數} }{ \\underbrace{ B_p \\left(\\omega_i\\right) }} \\end{align}$$\n$$\\begin{align}T\\left(\\omega_i,, \\omega_o\\right) &amp;&#x3D; \\sum_{q} \\underset{ \\text{光線傳輸系數} }{ \\underbrace{ t_q \\left(\\omega_o\\right)  }} \\cdot \\underset{ \\text{基函數} }{ \\underbrace{ B_q\\left(\\omega_i\\right) }} \\end{align}$$\n基本信號構成了正交函數系 $\\left{ B_{i}\\left(\\omega_i\\right) \\right}$ ，在空間域的圖像信號與各個基函數的點積運算可以得到該函數正交級數的各項係數：\n$$l_p &#x3D;  \\int_{\\Omega^+} L_{i} \\left( \\omega_i \\right) , \\overline{B_p\\left(\\omega_i\\right)}  ,\\mathrm{d}\\omega_i \\ t_q \\left(\\omega_o\\right)  &#x3D;  \\int_{\\Omega^+} T \\left( \\omega_i ,, \\omega_o \\right) , \\overline{B_q\\left(\\omega_i\\right)}  ,\\mathrm{d}\\omega_i \\$$\n\n推廣點積運算，兩個複變函數的點積是在給定區間上一個函數和另一個函數共軛的乘積的定積分。\n\nPRT 中選取 球諧函數（spherical harmonics，SH） 作為基函數進行變換。\n\n實時渲染中涉及的很多函數都是定義在球面上的函數，例如此處的 $L_{i} \\left( \\omega_i \\right)$ 和 $T\\left(\\omega_i\\right)$ 。對於這些函數，如果使用二維傅里葉變換，則在根據傅里葉係數及基函數於空間域中重建圖像信號函數時，定義域的球面上可能會出現一條“縫”，而定義在球面上的球諧函數不會；\n可以把環境光照圖保存為立方體圖（cube map），然後對立方體每一個面的子圖單獨做變換；\n\n\n另外，球諧函數還有一些其它的好處，例如可以快速地計算出旋轉光源後新的係數；\n對於球諧函數基函數，不僅 $\\int_{\\Omega} B_n\\left(\\omega\\right) ,B_m\\left(\\omega\\right) ,\\mathrm{d}\\omega &#x3D; 0$，而且 $\\int_{\\Omega} \\left[ B_n\\left(\\omega\\right) \\right]^2 ,\\mathrm{d}\\omega &#x3D; 1$ ，於是其構成的函數係是規范正交函數係；為了更進一步地追求效率，可以在誤差允許的範圍內省略變換後頻域中那些繁雜的、描述細節的高頻成分，只保留低階的球諧函數。\n\n球諧函數適合描述漫反射這樣的低頻信息，而對於高頻信息，雖然也可以描述，但是需要用到比較高階的球諧函數，才能得到比較好的效果，開銷較高。於是一些研究嘗試使用其它的基函數進行變換，例如小波變換（wavelet transform）。\n描述高頻信息時需要用到比較高階的球諧函數才能得到比較好的效果 圖源：[GAMES202 閆令琪]\n4.2 PRT 特殊材質4.2.1 PRT Diffuse Case對於朗伯模型描述的漫反射材質，它的 BRDF 是一個常數，而光線傳輸部分也與 ωo 無關：\n$$f_{r}\\left(\\omega_i ,, \\omega_o \\right) &#x3D; \\rho \\ T\\left(\\omega_i ,, \\omega_o\\right) &#x3D; T\\left(\\omega_i\\right) \\$$\n在繪製方程計算定積分時，BRDF 可以被拆解出來，可以理解為：\n$$\\begin{align} L\\left( \\omega_o \\right)  &amp;&#x3D; \\int_{\\Omega^{+}}  L_{i} \\left( \\omega_i \\right) \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right) \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i\\end{align}$$\n$$\\begin{align}&amp;&#x3D; \\int_{\\Omega^{+}} \\sum_{p} \\left[l_p \\cdot B_p\\left(\\omega_i\\right)\\right] \\cdot \\rho \\cdot \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\end{align}$$\n$$\\begin{align}&amp;&#x3D; \\rho \\sum_{p} l_p  \\underset{ \\text{恰好是光線傳輸用球諧函數線性表示} }{ \\underbrace{ \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot \\cos\\theta_i V\\left(\\omega_i\\right)  ,\\mathrm{d}\\omega_i }}\\end{align}$$\n$$\\begin{align}&amp;&#x3D; \\rho \\sum_{p} l_p \\cdot T_p \\left(\\omega_i\\right) &#x3D; \\rho \\cdot\\begin{bmatrix} l_0 &amp; l_1 &amp; \\cdots l_p \\end{bmatrix} \\begin{bmatrix} T_0 \\left(\\omega_i\\right) &amp; T_1 \\left(\\omega_i\\right) &amp; \\cdots &amp; T_p \\left(\\omega_i\\right) \\end{bmatrix}^T \\end{align}$$\n另一種理解方式：\n$$\\begin{align} &amp;L\\left( \\omega_o \\right)  &#x3D; \\int_{\\Omega^{+}}  L_{i} \\left( \\omega_i \\right) \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right) \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;\\quad\\quad\\quad &#x3D; \\int_{\\Omega^{+}} \\sum_{p} \\left[l_p \\cdot B_p\\left(\\omega_i\\right)\\right] \\cdot \\sum_{q} \\left[t_q \\cdot B_q\\left(\\omega_i\\right)\\right] ,\\mathrm{d}\\omega_i \\ &amp;\\quad\\quad\\quad &#x3D; \\rho \\sum_{p} \\sum_{q} l_p \\cdot t_q \\cdot \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot B_q\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;\\because \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot B_q\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i &#x3D; \\left{\\begin{array}{} 1 &amp; p &#x3D; q \\ 0 &amp; p \\ne q \\end{array}\\right. \\ &amp;\\therefore L\\left( \\omega_o \\right)  &#x3D; \\rho \\cdot \\sum_{k} l_k t_k \\quad\\quad \\color{Green}{k &#x3D; \\min\\left{ p ,, q \\right}} \\ &amp;\\quad\\quad\\quad\\quad,&#x3D; \\rho \\cdot\\begin{bmatrix} l_0 &amp; l_1 &amp; \\cdots l_k \\end{bmatrix} \\begin{bmatrix} t_0 &amp; t_1 &amp; \\cdots &amp; t_k \\end{bmatrix}^T \\end{align} \\$$\n於是，對於漫反射材質景物表面，根據 PRT 著色表面某一點的運算過程被簡化成了向量的點積運算。\n\n對於漫反射，使用前三階的球諧函數便可以得到比較好的近似；\n\n4.2.2 PRT Glossy Case對於有光澤（glossy）材質的繪製方程，則有：\n$$\\begin{align} L\\left( \\omega_o \\right)  &amp;&#x3D; \\int_{\\Omega^{+}}  L_{i} \\left( \\omega_i \\right) \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right) \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;&#x3D; \\int_{\\Omega^{+}} \\sum_{p} \\left[l_p \\cdot B_p\\left(\\omega_i\\right)\\right] \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right)  \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;&#x3D; \\sum_{p} l_p  \\underset{ \\text{恰好是光線傳輸用球諧函數線性表示} }{ \\underbrace{ \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right) \\cos\\theta_i V\\left(\\omega_i\\right)  ,\\mathrm{d}\\omega_i }}  \\ &amp;&#x3D; \\sum_{p} l_p \\cdot T_i\\left( \\omega_i, \\omega_o \\right) \\ &amp;&#x3D;\\begin{bmatrix} l_0 &amp; l_1 &amp; \\cdots l_p \\end{bmatrix} \\begin{bmatrix} T_0 \\left(\\omega_i, \\omega_o\\right) &amp; T_1 \\left(\\omega_i, \\omega_o\\right) &amp; \\cdots &amp; T_p \\left(\\omega_i, \\omega_o\\right) \\end{bmatrix}^T \\end{align} \\$$\n另一種理解方式：\n$$\\begin{align} &amp;L\\left( \\omega_o \\right)  &#x3D; \\int_{\\Omega^{+}}  L_{i} \\left( \\omega_i \\right) \\cdot f_{r}\\left( \\omega_i ,, \\omega_o \\right) \\cos\\theta_i V\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;\\quad\\quad\\quad &#x3D; \\int_{\\Omega^{+}} \\sum_{p} \\left[l_p \\cdot B_p\\left(\\omega_i\\right)\\right] \\cdot \\sum_{q} \\left[t_q\\left(\\omega_o\\right) \\cdot B_q\\left(\\omega_i\\right)\\right] ,\\mathrm{d}\\omega_i \\ &amp;\\quad\\quad\\quad &#x3D; \\sum_{p} \\sum_{q} l_p \\cdot t_q\\left(\\omega_o\\right) \\cdot \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot B_q\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i \\ &amp;\\because \\int_{\\Omega^{+}} B_p\\left(\\omega_i\\right) \\cdot B_q\\left(\\omega_i\\right) ,\\mathrm{d}\\omega_i &#x3D; \\left{\\begin{array}{} 1 &amp; p &#x3D; q \\ 0 &amp; p \\ne q \\end{array}\\right. \\ &amp;\\therefore L\\left( \\omega_o \\right)  &#x3D; \\sum_{k} l_k t_k\\left(\\omega_o\\right) \\quad\\quad \\color{Green}{k &#x3D; \\min\\left{ p ,, q \\right}} \\end{align} \\$$\n繼續把係數 $t_k\\left(\\omega_o\\right)$ 基於規范正交函數係 $\\left{ B_{r}\\left(\\omega_o\\right) \\right}$ 展開成正交級數：\n光傳輸矩陣元素基函數tk(ωo)&#x3D;∑rtk,r(ωo)⏟光傳輸矩陣元素⋅Br(ωo)⏟基函數\n$$t_k\\left(\\omega_o\\right) &#x3D; \\sum_{r}   \\underset{ \\text{光傳輸矩陣元素} }{ \\underbrace{ t_{k,r} \\left(\\omega_o\\right)  }} \\cdot \\underset{ \\text{基函數} }{ \\underbrace{ B_{r}\\left(\\omega_o\\right) }} \\$$\n於是有：\n$$\\begin{align} L\\left( \\omega_o \\right) &amp;&#x3D; \\sum_{k} l_k t_k\\left(\\omega_o\\right) \\ &amp;&#x3D;  \\sum_{k} l_k \\sum_{r} t_{k,r} B_{r}\\left(\\omega_o\\right) \\ &amp;&#x3D; \\begin{bmatrix} l_0 &amp; l_1 &amp; \\cdots &amp; l_k \\end{bmatrix} \\begin{bmatrix} t_{0,0} &amp; t_{0,1} &amp; \\cdots &amp; t_{0,r} \\ t_{1,0} &amp; t_{1,1} &amp; \\cdots &amp; t_{1,r} \\ \\vdots &amp; \\vdots &amp;\\ddots &amp;\\vdots \\ t_{k,0} &amp; t_{k,1} &amp; \\cdots &amp; t_{k,r} \\ \\end{bmatrix} \\begin{bmatrix} B_{0}\\left(\\omega_o\\right) \\ B_{1}\\left(\\omega_o\\right) \\ \\vdots \\ B_{r}\\left(\\omega_o\\right) \\end{bmatrix} \\end{align} \\$$\n於是，對於有光澤材質的景物表面，根據 PRT 著色表面某一點的運算過程被簡化成了向量和矩陣的乘法。\n\n有光澤的材質需要用到比漫反射更高階數的球諧函數；對於學術界，有時用到十階也仍覺得不夠；\n\n5 Signed Distance Function (SDF)\nDistance Function: 就是空間中任何一點，到某個物體的最小距離\nSigned: 就是加入規定負數代表在物體內部，正數則表示在物體外部。這樣不止定義了距離，還定義了方向\n\n5.1 SDF 的應用\nRay Marching\n以迭代方式遍歷射線，從而將每條射線有效地劃分為較小的射線段，並在每個步驟中對某些函數進行採樣\n\n\n生成軟陰影\n\n參考Karis B, Games E. Real shading in unreal engine 4[J]. Proc. Physically Based Shading Theory Practice, 2013, 4(3): 1.\n","slug":"GraphicQuest/GQ012 實時渲染3 實時環境光照：環境光照與預計算 環境光與Split Sum、PRT","date":"2022-12-15T02:51:05.874Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"791f4797b9f7bc6b1c27dbd08f25dd4c","title":"實現Flowmap","content":"1.實現Flowmap甚麼是Flowmap? 實際上可以理解成擁有流動材質的貼圖技術\n實際流程 (簡單版):\n\n下載Flowmap Painter, 地址\n下載以後，軟件會自帶一張水貼圖，以及可調整的向量場界面，嘗試一下軟件功能，繪製 Flowmap\n最後按下 “bake” 功能鍵完成 Flowmap\n打開Unity，放入製作好的Unity Shader，選取使用貼圖本身以及剛剛生成Flowmap\n完成\n\n\n2.uv mapping 回顧\n在uv座標中，每一個uv值都代表了在另一個紋理中不同的顏色值(圖)\n如果整張圖片都使用同一個uv值表示，我們只會採樣另一個紋理圖片的單一顏色(像素)\n\n3.1 Flowmap的原理一張帶有向量場信息的紋理貼圖\n\n一個平面上，平面上每一個點都代表一個向量，向量方向為運動方向\n通過顏色(RG兩種顏色)來記錄向量方向\n在Shader中偏移uv，對紋理進行探樣，模擬流動效果\n\n3.2 Flowmap Shader怎樣偏移uv?\n\n讓uv隨著時間偏移: uv - time\n如果 uv + time 會怎麼樣?\n\n\n從 flowmap 獲取流動方向\n在此之前，要將 flowmap 上的值[0,1]投影到方向向量[-1,1] (把flowmap上的數值*2-1)，記作 flowDir\nflowDir.xy * time\n\n\n讓流動無縫循環，把偏移控制在一定的範圍內（隨著時間進行，變形太過誇張）\n構造兩個相位差半個週期的波形函數\n使用以上這兩個波形函數，製作兩層採樣，用一層的採樣去覆蓋另一層的採樣，做用循環的效果\n\n\n\n4. 怎麼製作類似的效果(向量場信息)?在Wallpaper engine中，桌布製作器中擁有可以製作向量場貼圖的功能，我們可以嘗試在Wallpaper engine 製作不同的特效\n","slug":"GraphicQuest/GQ011 實現Flowmap","date":"2022-12-15T02:51:05.867Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"a896efca63e04f8beb46d5e9142b43a4","title":"實時渲染 延遲渲染 Deferred Rendering","content":"延遲渲染 Deferred Rendering1.1 甚麼是延遲渲染？\n\n\n\n\n\n\n\n\n　A single rendering pass could generate a color image in one target, object identifiers in another, and world-space distances in a third. This ability has also given rise to a different type of rendering pipeline, called Deferred shading, where visibility and shading are done in separate passes\n甚麼是延遲渲染？為什麼要延遲渲染？\n假設一個場景中，有10000個Mesh需要渲染，有100個Light，\n&#x2F;&#x2F; 示例\nint main()\n&#123;\n    for (int i &#x3D; 0; i &lt; 10000;++i)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 100;++j)\n        &#123;\n            RenderMesh(Mesh,Light)\n        &#125;\n    &#125;\n&#125;\n\nvoid RenderMesh(int Mesh,int Light)\n&#123;\n    for (int i &#x3D; 0; i &lt; Mesh * 3;++i)\n    &#123;\n        RenderTriange(Light);\n    &#125;\n&#125;\n在一個正常的場景，涉及的Mesh可能有上百萬個，如果此時我們還想要去渲染100個Light互相影響的結構，不就相當於把這幾百萬個Mesh再重新渲染100次？就算是RTX4090也hold不住\n所以延遲渲染的做法就是先做深度測試(Depth Test)，再做渲染\n2.1 延遲渲染的過程2.1.1 Geometry Pass(幾何處理階段):\n正常的渲染過程，只是我們不做光照處理。做深度測試，我們把在屏幕中所看見的場景中各種幾何信息暫存起來，我們叫這個暫存的地方叫 G-buffer\nG-buffer放甚麼幾何信息?你可以放:\nPosition (像素位置)\nNormals (光線)\nDiffuse Albedo RGB (漫反射)\nSpec-Power (高光反射)\nSpec-Intersity\n…\n\n\n\n\n2.1.2 Lighting Pass(光照處理階段):\n在這個階段，我們只需要渲染一個屏幕大小圖像就可以了\n在G-buffer中，我們已經存好了屏幕上的幾何信息，因此第一步就是獲取我們剛剛暫存信息\n在此基礎上，再使用多渲染目標(Multiple Render Targets, MRT)技術，就可以完成所有的渲染目標\nMRT: GPU硬件功能，它允許渲染管道一次將圖像渲染到多個渲染目標紋理\n\n\n\n\n3.1 延遲渲染的偽代碼方便理解其中的算法，這裡各種版本的延遲渣染算法的偽代碼\n\n通用版本的延遲著色算法偽代碼：For each object:\nRender to multiple targets\nFor each light:\nApply light as a 2D postprocess\n一個通用版本的deferred shading過程描述：“Standard” deferred shading is a 2-stage process:\n\n(1) draw (opaque) geometry storing its attributes (i.e. position as depth, normals, albedo color, specular color and other material properties) in a number of full screen buffers (typically 3 or 4)\n\n(2) for each light source, draw its volume and accumulate lit surface color into final render target\n兩個Pass的延遲著色算法偽代碼：Two-pass deferred shading algorithm\nPass 1: geometry pass\n- Write visible geometry information to G-buffer\nPass 2: shading pass\nFor each G-buffer sample, compute shading\n- Read G-buffer data for current sample\n- Accumulate contribution of all lights\n- Output final surface color\n多光源的延遲渲染的偽代碼：Many-light deferred shading algorithm\nFor each light:\n- Generate&#x2F;bind shadow&#x2F;environment maps\n- Compute light’s contribution for each G-buffer sample:\nFor each G-buffer sample\n- Load G-buffer data\n- Evaluate light contribution (may be zero)\n- Accumulate contribution into frame-buffer\n可以將這裡的多光源計算過程理解為，對每個光源創建一個屏幕空間包圍矩形，然後用光照shader渲染這個矩形\n\n4.1 延遲渲染 vs 正向渲染這邊對正向渲染和延遲渲染的特性做一個對照列舉：\n4.2 正向渲染正向渲染（Forward Rendering），先執行著色計算，再執行深度測試。\n正向渲染渲染n個物體在m個光源下的著色，複雜度為O(n*m)次。\nForward Rendering，光源數量對計算複雜度影響巨大，所以比較適合戶外這種光源較少的場景。\nForward Rendering的核心偽代碼可以表示為：\nFor each light:\n\tFor each object affected by the light: \n\t\tframebuffer +&#x3D; object * light\n4.3 正向渲染渲染管線\n4.4 延遲渲染延遲渲染( Deferred Rendering)，先執行深度測試，再執行著色計算。\n延遲渲染渲染n個物體在m個光源下的著色，複雜度為O(n+m)次。\nDeferred Rendering 的最大的優勢就是將光源的數目和場景中物體的數目在復雜度層面上完全分開。也就是說場景中不管是一個三角形還是一百萬個三角形，最後的複雜度不會隨 光源數目變化而產生巨大變化。\nDeferred Rendering的核心偽代碼可以表示如下，上文已經貼出過，這邊再次貼出，方便對比：\nFor each object: Render to multiple targets For each light: Apply light as a 2D postprocess\n4.5 延遲渲染渲染管線\n5.1 延遲渲染的優缺點分析這裡列舉一下經典版本的延遲渲染的優缺點。\n5.1.1延遲渲染的優點Deferred Rendering 的最大的優勢就是將光源的數目和場景中物體的數目在復雜度層面上完全分開。也就是說場景中不管是一個三角形還是一百萬個三角形，最後的複雜度不會隨光源數目變化而產生巨大變化。\n\n複雜度僅O(n+m)。\n只渲染可見的像素，節省計算量。\n用更少的shader。\n對後處理(post-processing)支持良好。\n在大量光源的場景優勢尤其明顯。\n\n5.1.2 延遲渲染的缺點\n內存開銷較大。\n讀寫G-buffer的內存帶寬用量是性能瓶頸。\n對透明物體的渲染存在問題。在這點上需要結合正向渲染進行渲染。\n對多重採樣抗鋸齒（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因為需要硬件開啟MRT。\n\n\n\n\n\n\n\n\n\n\n就是一般來說實時渲染都會用到Diffuse&#x2F;Specular或者Albeo&#x2F;Roughnee&#x2F;Metallic,以及其他數據（Normal，Depth），這樣會導致G-Buffer比較大，這也是為什麼到目前為止, 延遲渲染在手機平台都沒有成為主流的核心問題，同時也是VR不採用的主要問題，VR中要面對帶寬消耗x2的問題\n6.1 延遲渲染的改進針對延遲渲染上述提到的缺點，下面簡單列舉一些降低 Deferred Rendering 存取帶寬的改進方案。最簡單也是最容易想到的就是將存取的 G-Buffer 數據結構最小化，這也就衍生出了 Light Pre-Pass（即Deferred Lighting） 方法。另一種方式是將多個光照組成一組，然後一起處理，這種方法衍生了 Tile-Based Deferred Rendering。\n也就是說，常見的兩種Deferred Rendering的改進是：\n\n延遲光照 Light Pre-Pass（Deferred Lighting）\n分塊延遲渲染 Tile-BasedDeferred Rendering\n\n6.2 延遲光照 LightPre-Pass &#x2F; Deferred LightingLight Pre-Pass即Deferred Lighting（延遲光照），旨在減少傳統Defferred Rendering使用G-buffer 時佔用的過多開銷（reduce G-buffer overhead）\n延遲光照的主要渲染分成4個階段：\n\n幾何階段，渲染非透明物體，保存幾何信息；\n光照階段，保存光照信息；\nShading階段，再次渲染非透明物體，\n使用前向渲染半透明體。\n\n相對於延遲渲染，延遲光照所需的buff信息更少更輕量，且第三步開始都是前向渲染，可以對每個不同的幾何體使用不同的 shader 進行渲染，所以每個物體的材質屬性將有更多變化，而且延遲光照通常情況下可以使用MSAA (除一些新特性外)。\n延遲光照的具體思路：\n\n渲染場景中不透明（opaque ）的幾何體。將法線向量n和鏡面擴展因子（specular spread factor）m 寫入緩衝區。這個n&#x2F;m-buffer 緩衝區是一個類似 G-Buffer的緩衝區，但包含的信息更少，更輕量，適合於單個輸出顏色緩衝區，因此不需要MRT支持。\n\n渲染光照。計算漫反射和鏡面著色方程，並將結果寫入不同的漫反射和鏡面反射累積緩衝區。這個過程可以在一個單獨的pass中完成（使用MRT），或者用兩個單獨的pass。環境光照明可以在這個階段使用一個 full-screen pass進行計算。\n\n對場景中的不透明幾何體進行第二次渲染。從紋理中讀取漫反射和鏡面反射值，對前面步驟中漫反射和鏡面反射累積緩衝區的值進行調製，並將最終結果寫入最終的顏色緩衝區。若在上一階段沒有處理環境光照明，則在此階段應用環境光照明。\n\n\nLight Pre-Pass 的優點:\n\n可以使用MSAA(多重採樣抗鋸齒)。由於使用了Z 值和 Normal 值，就可以很容易找到邊緣，並進行採樣\n解決了渲染透明物體的問題\n複雜度僅O(2n+m)。\n\n7.1 分塊延遲渲染（Tile-Based Deferred Rendering）分塊（tiled）渲染，目的是在計算光照前對光照進行裁剪，以提升場景中光源較多時的性能表現。分塊和分簇和其它延遲或者前向渲染技術能兼容得比較好，現在的商業和in house引擎也都在使用。\n延遲渲染的瓶頸在於讀寫 G-buffer，在大量光源下，具體瓶頸將位於每個光源對 G-buffer的讀取及與顏色緩衝區（color buffer）混合。這裡的問題是，每個光源，即使它們的影響範圍在屏幕空間上有重疉，因為每個光源是在不同的繪製中進行，所以會重複讀取G-buffer中相同位置的數據，計算後以相加混合方式寫入顏色緩衝。光源越多，內存帶寬用量越大。\n而分塊延遲渲染的主要思想則是把屏幕分拆成細小的柵格，例如每 32 × 32 像素作為一個分塊（tile）。\n然後，計算每個分塊會受到哪些光源影響，把那些光源的索引儲存在分塊的光源列表裡。\n最後，逐個分塊進行著色，對每像素讀取 G-buffer 和光源列表及相關的光源信息。\n因此，G-buffer的數據只會被讀取1次且僅1次，寫入 color buffer也是1次且僅1次，大幅降低內存帶寬用量。不過，這種方法需要計算光源會影響哪些分塊，這個計算又稱為光源剔除（light culling），可以在 CPU 或 GPU（通常以 compute shader 實現）中進行。\n用GPU計算的好處是，GPU 計算這類工作比 CPU 更快，也減少 CPU／GPU 數據傳輸。而且，可以計算每個分塊的深度範圍（depth range），作更有效的剔除。\n8.1 實時渲染中常見的Rendering Path總結實時渲染中常見的幾種 Rendering Path\n目前已經提到的Rendering Path有：\n\n正向渲染 （Forward Rendering）\n延遲渲染 （Deferred Rendering）\n延遲光照 （Light Pre-Pass &#x2F; Deferred Lighting）\n分塊延遲渲染（Tile-Based Deferred Rendering）\n\n除此之外，還有如下一些後來提出的Rendering Path比較有趣：\n\nForward+（即Tiled Forward Rendering，分塊正向渲染）\n群組(分簇)渲染 Clustered Rendering\n\n以虛幻為例，虛幻的管線是普通版本的tiled deferred和forward+\n參考資料\n(虚幻引擎中的前向着色渲染器)[https://docs.unrealengine.com/5.0/zh-CN/forward-shading-renderer-in-unreal-engine/]\n(DX12渲染管线(3) - 分块&#x2F;分簇延迟渲染])[https://zhuanlan.zhihu.com/p/66884611]\n(TBDRっぽい何かを実装してみた)[https://qiita.com/Onbashira/items/f5905c2fc227733edb78#%E9%95%B7%E6%89%80]\n(タイルベースポイントライトカリングでのタイルフラスタム計算メモ)[http://momose-d.cocolog-nifty.com/blog/2014/03/index.html]\n(【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染(Deferred Rendering)的前生今世)[https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8AReal-Time%20Rendering%203rd%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Content/BlogPost07/README.md]\n\n","slug":"GraphicQuest/GQ010 實時渲染2 延遲渲染 Deferred Rendering","date":"2022-12-15T02:51:05.862Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"93a53427e5b87ad502fcef83077b7809","title":"實時渲染 Shadow Mapping、PCSS、VSSM、SDF Shadows、VSM、MSM","content":"Shadow Mapping、PCSS、VSSM、SDF Shadows、VSM、MSM1. Shadow Mapping (陰影映射)1.1 陰影映射算法流程Shadow Mapping 為圖像空間算法，用於快速判斷Shadow point 是否於陰影之中\n\n好處: 不需要場景的幾何信息(只需屏幕信息)\n壞處: 存在自遮擋和走樣的問題陰影映射算法分成兩步:\n\n\n以光源為視點，生成場景的深度圖(Shadow map)\n將著色點(Shadow point)到光源的距離和深度圖中的對應值作比較，判斷該點是否處位陰影之中\n\n\n&#x2F;&#x2F; Shadow Mapping \n&#x2F;&#x2F; 計算有多少點不在陰影內 \nint noShadowCount &#x3D; 0;\n&#x2F;&#x2F; 深度圖中的對應值\nfloat closestDepth &#x3D; unpack(closestDepthVec);\n&#x2F;&#x2F; 著色點到光源距離\nfloat currentDepth &#x3D; coords.z;\nif(currentDepth &lt; closestDepth)&#123;\n    noShadowCount +&#x3D; 1;\n&#125;\n1.2 自遮擋問題甚麼是自遮擋?在第一步生成的深度圖中，深度變化差可能比較大，但深度圖分辨率不夠，所以在生成的深度圖採樣的深度有誤差\n在第二步中，假設著色點在光源處上可以看見，但當計算著色點到光源距離時，會誤以為比從深度圖讀取的距離長( 著色點到光源距離 &gt; 深度圖讀取的距離 )，算法會認為這個點位於陰影之中，以為著色點在光源處上看不見。\n\n簡單的解決方法 偏倚 bias加入額外的變量bias作比較\n如果(著色點到光源距離 &lt; 深度圖讀取的距離 + bias)，有多少點不在陰影內 \n&#x2F;&#x2F; Shadow Mapping \n&#x2F;&#x2F; 計算有多少點不在陰影內 \nint noShadowCount &#x3D; 0;\n&#x2F;&#x2F; 深度圖中的對應值: closestDepthVec為深度圖\nfloat closestDepth &#x3D; unpack(closestDepthVec);\n&#x2F;&#x2F; 著色點到光源距離\nfloat currentDepth &#x3D; coords.z;\n&#x2F;&#x2F; 加入額外的變量作比較\nif(currentDepth &lt; closestDepth + 0.01)&#123;\n    noShadowCount +&#x3D; 1;\n&#125;\n\n\n1.3 走樣問題 Aliasing生成的陰影可能會呈現階梯狀，仍然是深度圖分辨率不足的問題\n2.1 PCF (Percentage Closer Filtering) 反走樣改善剛剛提及的階梯狀陰影問題\nPCF流程\n對於某一個著色點p，先計算該點在場景中與光源的距離 $D_{scene}(p)$\n\n取濾波卷積核w，根據卷積核的呎吋，以p點為中心，取深度圖中附近區域內保存的深度信息 $D_{SM}(q), q \\in N(p)$\n\n計算可見性判斷，並得出結果 $X^+[D_SM(q) - d_{scene}(p)]$\n\n根據卷積核的權重w(p,q)，對結果進行加權平均，得到p點最終可見性結果\n\n\n$$V(p) &#x3D; \\sum_{q \\in N(p)}w(p,q) * X^{+}[D_{SM}(q) - d_{scene}(p)]$$\n$$X^{+}(n) &#x3D;\\begin{aligned}    1 &amp; &amp; n &gt; 0 \\    0 &amp; &amp; n&lt;&#x3D;0\\end{aligned}$$\n假設已得到濾波卷積核w，那麼它的均值濾波(取平均值)為0.6667\n$$w &#x3D; \\begin{bmatrix}    1 &amp; 0 &amp; 1 \\    1 &amp; 0 &amp; 0 \\    1 &amp; 1 &amp; 1\\end{bmatrix}, 6 &#x2F; 9 &#x3D; 0.6667$$\n2.2 PCF 在 GAMES202 homework 1 的 實現過程\n需要完善 phongFragment.glsl 中的 PCF(sampler2D shadowMap, vec4shadowCoord, float filterSize) 函数。我们推荐在一个圆盘滤波核中进行随机采样，采用这种方案的原因是可以简化后续PCSS Shader 的编写同时可以使软阴影上模糊的部分更显圆润自然，计算出来的伴影直径可与单位圆盘上的采样点相乘生成 ShadowMap 上的采样坐标\n（值得注意的是随机采样函数的质量将与最终渲染效果的好坏息息相关，我们在框架中提供了泊松圆盘采样和均匀圆盘采样两种采样函数，替换使用对比一下两种采样函数的细微区别，我们也鼓励使用其他的采样方法）。\n\n&#x2F;&#x2F; 採樣點數量\n#define NUM_SAMPLES 20\nvec2 poissonDisk[NUM_SAMPLES];\nfloat PCF(sampler2D shadowMap, vec4 coords) \n&#123;\n  &#x2F;&#x2F; 泊松分佈採樣 （Poisson-Disk Sample）\n  &#x2F;&#x2F; 圓範圍內隨機取一系列坐標作為採樣點，但是這些坐標還需要滿足一定約束，即坐標與坐標之間至少有一定距離間隔\n  poissonDiskSamples(coords.xy);\n  &#x2F;&#x2F; 均勻圓盤分佈採樣（Uniform-Disk Sample）\n  &#x2F;&#x2F; 圓範圍內隨機取一系列坐標作為採樣點；看上去比較雜亂無章，採樣效果的 noise 比較嚴重。\n  &#x2F;&#x2F;uniformDiskSamples(coords.xy);\n\n  &#x2F;&#x2F; shadow map 的大小, 越大滤波的范围越小\n  float textureSize &#x3D; 400.0;\n  &#x2F;&#x2F; 濾波的波長\n  float filterStride &#x3D; 5.0;\n  &#x2F;&#x2F; 濾波窗口的範圍\n  float filterRange &#x3D; 1.0 &#x2F; textureSize * filterStride;\n  &#x2F;&#x2F; 計算有多少點不在陰影內\n  int noShadowCount &#x3D; 0;\n  for( int i &#x3D; 0; i &lt; NUM_SAMPLES; i ++ ) &#123;\n    vec2 sampleCoord &#x3D; poissonDisk[i] * filterRange + coords.xy;\n    vec4 closestDepthVec &#x3D; texture2D(shadowMap, sampleCoord); \n    float closestDepth &#x3D; unpack(closestDepthVec);\n    float currentDepth &#x3D; coords.z;\n    &#x2F;&#x2F; 簡單理解\n    &#x2F;&#x2F; float closestDepth &#x3D; unpack(texture2D(shadowMap,coords.xy+disk[i]*0.001).rgba);\n    if(currentDepth &lt; closestDepth + 0.01)&#123;\n      noShadowCount +&#x3D; 1;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 根據卷積核的權重w(p,q)，對結果進行加權平均\n  float shadow &#x3D; float(noShadowCount) &#x2F; float(NUM_SAMPLES);\n  return shadow;\n&#125;\n\n效果圖\nLightMVP 使用\n\n\nPhongMaterial.js的buildPhongMaterial()函數通過調用PhongMaterial\nShadowMaterial.js的buildShadowMaterial()函數通過調用ShadowMaterial\n在ShadowMaterial中進行CalcLightMVP()\n計算過後在loadOBJ中結合定義的transform和scale賦值傳入material\n\n\n\n3.1 Soft Shadow當面光源照射物體時，會在物體後面產生軟陰影（soft shadow）。軟陰影邊緣的柔和程度不固定，會隨著遮擋程度的變化而變化。\n雖然上一節介紹的 PCF 技術可以使陰影的邊緣變得柔和，但是單純地使用 PCF 並不能得到軟陰影，因為 PCF 濾波卷積核的尺寸固定，於是得到的陰影邊緣柔和程度也是固定的。\n要想得到軟陰影，可以在 PCF 的基礎上進一步發展，根據遮擋程度的變化而動態調整濾波卷積核的尺寸，使陰影邊緣的柔和程度隨著遮擋程度的變化而變化。\n4.1 PCSSPCSS（Percentage Closer Soft Shadows）是一種在 PCF 的基礎上得到的軟陰影生成技術，它根據著色點和光源之間遮擋物的相對平均深度來判斷著色點的被遮擋程度，依此選擇合適的 PCF 濾波卷積核尺寸，使得陰影邊緣的柔和程度隨著遮擋程度的變化而變化。\nPCSS 算法可分為三步：\n\n遮擋物搜索（blocker search）： 在深度圖上計算著色點附近給定區域的平均遮擋物深度 $d_{blocker}$ ； 這個搜索遮擋物區域的範圍可以是恆定的，例如固定為 $5*5$ ， 也可以使用啟發法（heuristics），根據光源的尺寸 $w_{light}$ 和著色點與光源之間的距離 $d_{receiver}$  確定搜索遮擋物區域的範圍；\n半影估計（penumbra estimation）： 假設光源、遮擋物和著色點所在表面相互平行，根據光源的尺寸 $w_{light}$ ，著色點與光源之間的距離 $d_{receiver}$ 和平均遮擋物深度$d_{blocker}$ 估計陰影在著色點處的柔和程度 $w_{penumbra} &#x3D; \\frac{d_{receiver} - d_{blocker}}{d_{blocker}}$ ；\nPCF：執行 PCF 算法，而 PCF 卷積核的尺寸和半影估計 $w_{penumbra}$ 成正比；\n\n4.2 PCSS 在 GAMES202 homework 1 的 實現過程\n需要完善 phongFragment.glsl 中的 findBlocker(sampler2D shadowMap,vec2 uv, float zReceiver)。findBlocker 函数中需要完成对遮挡物平均深度的计算。\n需要完善 phongFragment.glsl 中的 PCSS(sampler2D shadowMap, vec4 shadowCoord) 函数\n\n詳細在 GAMES202 homework 1 的 實現過程\n\n\nfindBlocker(sampler2D shadowMap,vec2 uv, float zReceiver)函數實現\nfloat findBlocker( sampler2D shadowMap,  vec2 uv, float zReceiver ) &#123;\n  int blockerNum &#x3D; 0;\n  float block_depth &#x3D; 0.;\n  float shadowmapSize &#x3D; 2048.;\n  float Stride &#x3D; 50.;\n\n  poissonDiskSamples(uv);\n  \n  for (int i &#x3D; 0; i &lt; NUM_SAMPLES;++i)\n  &#123;\n    vec4 shadow_color &#x3D; \n      texture2D(shadowMap,uv + poissonDisk[i] * Stride &#x2F; shadowmapSize);\n    float shadow_depth &#x3D; unpack(shadow_color);\n    if (zReceiver &gt; shadow_depth + 0.01)\n    &#123;\n      blockerNum++;\n      block_depth +&#x3D; shadow_depth;\n    &#125;\n  &#125;\n  if (blockerNum &#x3D;&#x3D; 0)\n    return 1.;\n  return float(block_depth) &#x2F; float(blockerNum);\n&#125;\n\n\n\n\n5.1 VSSMPCSS 算法的第一步為了估計著色點平均遮擋物深度 $z_{occ}$ ，需要讀取深度圖中該點附近所有紋元（texel）保存的深度，並與著色點的深度進行比較，求取那些比著色點深度更小的紋元深度的平均值，而在第三步為了得到平均可見性結果，也要再次重複這個統計過程。\nVSSM（Variance Soft Shadow Mapping） 近似了這個統計過程，大大加速了 PCSS 第一步和第三步的估計。加速的統計過程可簡單地分為如下兩步：\n計算著色點附近深度分佈的均值和方差；借助不等式估計該點附近未遮擋物的平均深度 $z_{occ}$ 或該點的可見性判斷結果 $V(p)$ ；\n5.1.1 計算深度分佈的均值和方差隨機變量 $X$ 的數學期望 $E(X)$ 和方差 $Var(X)$ 存在如下關係：\n$$(1): Var(X) &#x3D; E(X^2) - E^2(X)$$\n只需記錄下隨機變量 $X$ 的數學期望 $E(X)$ 和 2階原點矩 $E(X^2)$ ，便能得到隨機變量所服從概率分佈的均值和方差。於是，在生成深度圖時，不僅記錄場景的深度 $z$ ，也額外記錄場景深度的平方 $z^2$ ，然後計算各自的 SAT（summed area table）。(類似前綴和)\n指定著色點附近區域的查詢範圍後，根據深度 SAT 和深度平方 SAT，可以快速地獲取著色點附近深度的平均值 $(z^2){arg}$ 和深度平方的平均值 $(z{arg})^2$ ，分別作為深度分佈的均值和  階原點矩，並根據公式(1) 得到了深度分佈的方差 $(z^2){arg}-(z{arg})^2$\n5.1.2 通過不等式估計未遮擋物的平均深度或著色點的可見性判斷結果切比雪夫不等式（Chebychev’s inequality）刻畫了概率分佈的概率密度函數，均值和方差之間的關係，其內容如下：\n$$P(x &gt; t) \\leq \\frac{\\sigma^2}{\\sigma^2 + (t - \\mu)^2}$$\n將著色點 $p$ 的深度記作 $z_t$ ，則 $P(x &gt; t)$ 即是該著色點附近區域內，未被遮擋的紋元在所有紋元中所佔的比例。\nVSSM 直接假設切比雪夫不等式中等號成立：\n$$P(z &gt; z_t) &#x3D; \\frac{(z^2){arg}-(z{arg})^2}{(z^2){arg}-(z{arg})^2 + (z_{t}-z_{arg})^2}$$\n如果此時對應於 PCSS 的第三步，則便直接得到了著色點 $p$ 的最終可見性判斷結果 $V(p) &#x3D; P(z &gt; z_t)$ 。\n如果此時對應於 PCSS 的第一步，則繼續假設未遮擋物的平均深度等於著色點的深度 $z_{unocc} &#x3D; z_t$ ，並將著色點附近的遮擋物平均深度記作 $z_{}$ ，未遮擋物平均深度記作 ，於是存在如下關係：\n$$[1-P(z&gt;z_t)] * z_{occ} + P(z &gt; z_t) * z_{unocc} &#x3D; z_{avg}$$\n代入相應的數值，便可以估計出遮擋物的平均深度 $z_{occ}$ 以用於 PCSS 第二步估計半影。\n6 Moment Shadow Mapping (MSM)VSSM 使用切比雪夫不等式估計著色點附近深度分佈的累積概率函數，進而計算該點附近未被遮擋的紋元占所有紋元的比例。此時，累計概率函數的重建僅用到了均值和  階原點矩。 Moment Shadow Mapping 在其基礎上對重建步驟作了改進，在重建累計概率函數時用到了更高階的原點矩，得到了更準確的擬合。\n\n因為考慮了深度的更高階項，所以消耗了更多的存放空間，重建時也消耗了更多的資源，但是的確緩解了 VSSM 生成陰影時的漏光等現象。\n\n7 Distance Field Soft Shadows和 PCSS 系列技術不同，distance field soft shadows 依靠有向距離場而不是陰影圖來生成軟陰影。\n有向距離場（signed distance field，SDF）  保存了三維場景中任一點與距離它最近的景物表面之間的距離。如果該點在景物內部，則距離是負數，否則是正數。\n從著色點 $p$ 發射一根指向光源的光線，在光線傳播的過程中記錄當前點 $p$ 的有向距離場數值 $sdf(p)$ 和當前點到著色點之間的距離，計算相應的角度，並記錄下光線傳播過程中最小的那個角度 $\\theta$ ，則這個角度代表了從著色點從該方向向光源望去時未被其它物體遮擋的“安全”視角。\n\n這個“安全”角越小，則著色點被其它物體遮擋的程度越大，於是可以根據“安全“角的大小調整陰影的柔和程度，由此得到軟陰影。\n通常，”安全“角  的計算並非直接求取反三角函數，而是使用如下公式以減少計算耗費：\n$$\\theta &#x3D; min\\big({\\frac{k * sdf(p)}{||p - o||},1}\\big)$$\n參數 $k$ 控制了陰影邊緣的柔和程度， $k$ 越大，則陰影的邊緣則越柔和。\nDistance Field Soft Shadows 可以生成相對高質量的軟陰影，並且速度較快，但是還是存在走樣問題，而且有向距離場需要預計算並存儲場景中每個三維點的深度信息，和 PCSS 系列技術相比消耗了更多的存儲空間，因為後者在生成深度圖時只需要計算並存儲光源處的深度信息即可。.\n為了避免生成有向距離場時需要計算場景中每個三維點的信息，一些研究提出可以使用八叉樹之類的層次化數據結構細分場景。對於場景中那些遠離任何景物表面的區域，細分的層級可以粗糙一些，如此便減少了資源耗費。\n參考資料\n有向距離場（Signed Distance Field）（SDF）:\n虚幻引擎网格体距离场 | 虚幻引擎5.0文档 (unrealengine.com)\n\n","slug":"GraphicQuest/GQ009 實時渲染1_Shadow Mapping、PCSS、VSSM、SDF Shadows","date":"2022-12-15T02:51:05.856Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"63f08a5595b545f21f86b9f931310211","title":"材質和外觀","content":"1.材質和外觀在計算機圖形學中，紋理貼圖是使用圖像、函數或其他數據源來改變物體表面外觀的技術。例如，可以將一幅磚牆的彩色圖像應用到一個多邊形上，而不用對磚牆的幾何形狀進行精確表示。當觀察這個多邊形的時候，這張彩色圖像就出現在多邊形所在位置上。只要觀察者不接近這面牆，就不會注意到其中幾何細節的不足（比如其實磚塊和砂漿的圖像是顯示在光滑的表面上的事實）。通過這種方式將圖像和物體表面結合起來，可以在建模、存儲空間和速度方面節省很多資源\n大尺度繪製:\n\n覆蓋很多個像素\n由頂點，三角形，其他的幾何圖元表示\n例如: 角色的四肢\n\n中尺度(細節)繪製: (Bump Mapping 重點)\n\n覆蓋好幾個像素\n細節可能特別複雜，無法使用單個三角形渲染\n細節可能相對較大，可以觀察看到幾個像素以上的變化\n例如: 人臉的皺紋、肌肉的褶皺、磚頭的縫隙\n\n小尺度繪製:\n\n一個像素\n通常使用紋理貼圖作為參數\n模擬了物體表面微觀幾何的相互作用例如:\n\n\n有光澤的物體表面是光滑的、漫反射的物體，在微觀下表面是粗糙的 \n角色的皮膚和衣服看起來也是不同的，因為使用了不同的著色模型&#x2F;不同的參數\n\n2.Bump Mapping模擬中尺度的常用方法之一，可以讓觀察者感受到比模型尺度更小的細節\n思路：\n\n在紋理中將尺度相關的信息編碼進去\n著色過程中，用受到干擾的表面去代替真實的表面\n這樣一來，表面就會有小尺度的細節原理：\n從物體表面的貼圖進行變化然後再進行光照計算的一種技術\n主要的原理是通過改變表面光照方程的法線，而不是表面的幾何法線，或對每個待渲染的像素在計算照明之前都要加上一個從高度圖中找到的擾動，來模擬凹凸不平的視覺特徵\n例如：\n給法線分量添加噪音（法線映射貼圖）\n在一個保存擾動值的紋理圖中進行查找（視差映射、浮雕映射貼圖）\n\n\n是一種提升物體真實感的有效方法， 且不用提升額外的幾何復雜度（不用改模型）\n\n2.1 不同的凹凸映射\nBump Mapping: 凹凸貼圖\nNormal Mapping: 法線貼圖\nDisplacement Mapping: 移位貼圖\nParallax Mapping (Virtual Displacement Mapping): 視差貼圖\nRelief Mapping (Steep Parallax Mapping): 浮雕貼圖\n\n\n用處非常廣泛，如增加模型的細節效果、或者做特殊的畫面表現 \n最常用的：\n法線映射\n增加法線貼圖後，會對局部的物體表面產生擾動，進而改變明暗關係，來達到增加表面細節的效果。\n\n\n\n\n很多映射都會用到法線貼圖\n\n2.2 Normal Mapping2.2.1 原理法線貼圖：存有物體局部表面法線信息的一張貼圖\n\n使用過程：\n在計算光照時，程序會去讀取法線圖，冰獲取到當前像素點的法線信息，結合光照信息進行光照計算。\n\n\n優點：\n使用法線貼圖來計算光照，可以讓物體表現出更多豐富的細節，且隨著光照方向的變化而變化，這是普通的貼圖做不到的。\n\n\n生成：\n法線貼圖一般由高模映射到對應的低模上來生成。\n對於金屬、木頭這類細節豐富的物體，可以藉助程序化的軟件，如PS、SD來生成\nopengl-tutorial教程: Tutorial 13 : Normal Mapping\n\n\n\n2.2.2 實際使用\nclipdrop.co&#x2F;relight\n使用了AI的方法去生成了一張法線貼圖，我們就可以使用法線貼圖做出打光的效果\n\n2.2.3 存儲：切線空間法線的存儲，一般會放到模型的切線空間中\n\n切線空間：\n\n以物體表面的切線，副切線和法線組成的幾何空間\n每個頂點都有屬於自己的切線空間，這個空間的原點是頂點本身，z軸是頂點的法線方向（n），x軸是頂點的切線方向（t），y軸有前邊兩個軸叉乘而來，被稱為副切線（b）或者副法線。\n\n\n\n在計算光照時，需要把相關的向量放在統一的坐標系下進行運算。此時就需要不同空間坐標的轉換矩陣（世界空間轉切線空間&#x2F;切線空間轉世界空間）\n\n\n2.2.4 世界空間和切線空間的轉換將世界坐標系下頂點的法線（Normal）、切線（Tangent）、副切線（Bitangent）作為切線空間坐標系的正交基。用這三個向量的標準正交基構建轉換矩陣。對應關係為：法線方向作為z軸，切線方向作為x軸，副切線方向作為y軸\n\n轉換矩陣：\n切線空間到世界空間的轉換矩陣為一個3×3的旋轉矩陣，一般稱為TBN矩陣\n世界空間到切線空間的轉換矩陣為上述TBN矩陣的逆矩陣，因為是正交矩陣，所以逆矩陣就是它的轉置矩陣\nGLSL-TBN矩阵\n\n\n\n$$TBN &#x3D; \\begin{bmatrix}    T_x &amp; B_x &amp; N_x \\    T_y &amp; B_y &amp; N_y \\    T_z &amp; B_z &amp; N_z \\\\end{bmatrix}$$\n$$TBN-1 &#x3D; \\begin{bmatrix}    T_x &amp; B_x &amp; N_x \\    T_y &amp; B_y &amp; N_y \\    T_z &amp; B_z &amp; N_z \\\\end{bmatrix}^T &#x3D;\\begin{bmatrix}    T_x &amp; T_y &amp; T_z \\    B_x &amp; B_y &amp; B_z \\    N_x &amp; N_y &amp; N_z \\\\end{bmatrix}$$\n\n旋轉矩陣的逆&#x3D;旋轉矩陣的轉置 (games101 lesson 4)\n轉換矩陣完成之後，接下來就是光照計算\n將光照計算中需要的數據，例如光照方向、觀察方向、法線方向等參數，帶入到光照模型中計算\n\n\n\n2.2.5 切線空間的優點法線存在各個空間裡都可以，但關鍵不只是存在哪裡，還有後續的光照計算\n\n切線空間的好處\n自由度高。\n\n\n模型空間下是絕對法線信息（僅可以用在創建它時的那個模型）\n而切線空間下的是相對法線信息，是對當前物體法線的擾動。 （可以復用）\n\n\n可進行uv動畫。\n\n\n比如：移動uv坐標來實現凹凸移動效果\n\n\n可以重用法線紋理。\n\n\n比如：一個立方體，6個面可以用一張法線貼圖\n\n\n可壓縮。\n\n\n由於切線空間下貼圖中法線的Z方向總是正方向（模型空間下可以是負的），那麼我們只存XY（切線和副切線）就能推出Z（法線）了，可以少存一個。\n\n\n\n2.2.6 法線貼圖在Unity中的壓縮格式在非移動平台上，會把法線貼圖轉化為DXRT5nm格式\n\n這個格式只有兩個有效GA通道（就是上邊說的只存xy，推出z） ，分別對應法線的y、x分量可以節省空間。\n在UnityCG.cginc中，提供了UnpackNormal()函數，可以解碼法線貼圖，它是對法線紋理的採樣結果的一個反映射操作，其對應的法線紋理需要設置為Normal map的格式，才能使用該函數，如下是函數的原型：&#x2F;&#x2F; Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n&#x2F;&#x2F; Note neutral texture like &quot;bump&quot; is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm&#x2F;BC5\nfixed3 UnpackNormalmapRGorAG(fixed4 packednormal)\n&#123;\n    &#x2F;&#x2F; This do the trick\n  packednormal.x *&#x3D; packednormal.w;\n\n  fixed3 normal;\n  &#x2F;&#x2F;法線分量範圍[-1,1]映射成像素[0,1]   Normal&#x3D;pixel*2-1\n  normal.xy &#x3D; packednormal.xy * 2 - 1; \n  &#x2F;&#x2F;用xy分量求出z分量 根號下1-x²*y²&#x3D;z\n  normal.z &#x3D; sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n  return normal;\n&#125;\ninline fixed3 UnpackNormal(fixed4 packednormal)\n&#123;\n#if defined(UNITY_NO_DXT5nm)\n    return packednormal.xyz * 2 - 1;\n#else\n    return UnpackNormalmapRGorAG(packednormal);\n#endif\n&#125;\n在移動平台上，使用傳統RGB通道。inline fixed3 UnpackNormal(fixed4 packednormal)\n&#123;\n#if defined(SHADER_API_GLES)  defined(SHADER_API_MOBILE)\n    return packednormal.xyz * 2 - 1;&#x2F;&#x2F;原理同上\n#else\n    fixed3 normal;\n    normal.xy &#x3D; packednormal.wy * 2 - 1;\n    normal.z &#x3D; sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n    return normal;\n#endif\n&#125;\nnormal.xy &#x3D; packednormal.xy * 2 - 1; \n關於解碼法線貼圖時要做一個“*2-1”的操作\n法線紋理中存的就是表面法線，由於法線分量範圍為[-1,1]，像素的分量範圍為[0,1] \n因此我們通常需要做一個映射：pixel&#x3D;（normal+1）&#x2F;2，解碼時就要做一個反向的操作\n\n\n關於 normal.xy *&#x3D; scale；\n對法線的擾動效果進行縮放\n\n\n\n2.3 Parallax Mapping2.3.1 原理\n視差貼圖Parallax Mapping，又稱為 Offset Mapping，以及virtual displacement mapping)，於2001年由Kaneko引入，由Welsh進行了改進和推廣\n主要為了賦予模型表面遮擋關係的細節。引入了一張高度圖\n可以和法線貼圖一起使用，來產生一些真實的效果\n高度圖一般視為頂點位移來使用，此時需要三角形足夠多，模型足夠精細，否則看起來會有塊狀\n如果在有限的三角形面的情況下，怎麼辦？這就用到了視差映射技術\n視差映射技術：\n核心：改變紋理坐標\n需要一張存儲模型信息的高度圖，利用模型表面高度信息來對紋理進行偏移（例如：低位置的信息被高位置的信息遮擋掉了，所以會採樣更高的信息）\n\n\n\n2.3.2 實際使用詳見參考資料\n2.3.3 視差映射的實現\n和法線貼圖一樣，是欺騙眼睛的做法（只改變紋路，不增加三角形）\n我們的模型在切線空間下，所有的點都位於切線和副切線組成的平面內（圖中0.0點），但實際上物體要有更豐富的細節。\n例如圖中的情況\n如果不使用視差貼圖，要計算當前視角下，片元A點（黃色）的信息，就是圖中的Ha\n實際使用視差貼圖時，真實的情況應該是視線和A點延長線和物體的交點，也就是B點，相應的就是Hb\n\n\n\n視差映射的具體算法：如何在知道A的uv值的情況下，算出B的uv值\n\n知道AB兩者的偏移量即可\n\n偏移量的獲得：用近似的方法去求解\t\n\n首先拿A的高度信息進行採樣，得到物體表面距離水平面（0.0）的深度值Ha。\n用深度值Ha和視線的三角關係算出物體上等比的偏移方向，算出近似的B點（可以看到圖中近似點B和實際點B還是有挺大差距的，所以模擬度比較低）\n\n\n\n\nfloat2 ParallaxMapping(float2 texCoords,float3 viewDir)\n&#123; \n    float height &#x3D; texture(depthMap, texCoords).r;    \n    float2 p &#x3D; viewDir.xy &#x2F; viewDir.z * (height * height_scale);\n    return texCoords - p;  &#x2F;&#x2F;uv减偏移值\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; i.uv.xy +&#x3D; offuv;\n    &#x2F;&#x2F; i.uv.zw +&#x3D; offuv;\n&#125;\n得到偏移之後B點的uv，再去對法線貼圖進行採樣、計算時，就不會採樣A點了，而是B點\n2.4 Steep Parallax Mapping (陡視差映射)2.4.1 原理\n陡峭視差映射，不像簡單的視差映射近似，並不只是簡單粗暴的對紋理坐標進行偏移而不檢查合理性和關聯性，會檢查結果是否接近於正確值。這種方法的核心思想是把表面的深度切分成等距的若干層。然後從最頂端的一層開始採樣高度圖，每一次會沿著V的方向偏移紋理坐標。如果點已經低於了表面（當前的層的深度大於採樣出的深度），停止檢查並且使用最後一次採樣的紋理坐標作為結果。\n將物體表面分為若干層，從最頂端開始採樣，每次沿著視角方向偏移一定的值\n如果當前採樣的層數，大於實際採樣的層數，就停止採樣。\n例如圖中D點，採樣到0.75層，實際是0.5層，就停止採樣，返回偏移坐標\n\n\n\n\n陡視差映射的算法：（計算偏移點的過程）\n\n首先對A點採樣，得到深度大約為0.8的位置，而其對應視線深度為0.0，不符合，繼續採樣\n採樣B點，深度為1，視線深度為0.25，不符合，繼續採樣\n採樣C點，深度大約為0.8，視線深度為0.5，不符合，繼續採樣\n採樣D點，採樣深度為0.5，視線深度約為0.75，符合上述的條件，認為是比較合理的一個偏移點，就返回結果（return）\n\nSteep Parallax Mapping 的問題：\n\n在於分層機制，如果\n分層多，性能開銷就會大；\n分層小，渲染鋸齒就比較明顯。\n\n\n\n\n一種做法：可以根據視角v和法線n的角度限定採樣層數\n\n\n鋸齒問題會在浮雕貼圖上做改善\n\n&#x2F;&#x2F;&quot;陡峭视差贴图&quot;\nvec2 steepParallaxMapping(vec2 uv, vec3 viewDir) \n&#123;\n\tfloat layerDepth &#x3D; 1.0 &#x2F; ubo.numLayers;\n\tfloat currLayerDepth &#x3D; 0.0;\n\tvec2 deltaUV &#x3D; viewDir.xy * ubo.heightScale &#x2F; (viewDir.z * ubo.numLayers);\n\tvec2 currUV &#x3D; uv;\n\tfloat height &#x3D; 1.0 - textureLod(sNormalHeightMap, currUV, 0.0).a;\n\tfor (int i &#x3D; 0; i &lt; ubo.numLayers; i++) &#123;\n\t\tcurrLayerDepth +&#x3D; layerDepth;\n\t\tcurrUV -&#x3D; deltaUV;\n\t\theight &#x3D; 1.0 - textureLod(sNormalHeightMap, currUV, 0.0).a;\n\t\tif (height &lt; currLayerDepth) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\treturn currUV;\n&#125;\n\n2.5 Relief Mapping (浮雕映射)2.5.1 原理\n可以更精確的計算uv偏移量(視差如果偏移量大的話就會失真)、提供更多的深度、還可以做自陰影以及閉塞效果\n例如下圖：可以看到浮雕的凹凸深度明顯更大，且凹凸有自陰影效果\n浮雕映射一般用射線步進和二分查找來決定uv偏移量\n第一步：射線步進部分，和視差貼圖一樣— 第二步：二分查找部分：通過射線步進找到合適的步進後，在此步進內使用二分查找來找到精確的偏移值\n\n\n為什麼不直接使用二分查找？\n會產生比較大的誤差\n下圖為例\n如果直接使用二分查找，在深度0和1的中間的1點，進一步為2點 -&gt; 3點 -&gt;Q點。但我們要的結果是P點，可以看到結果很明顯是錯誤的\n\n\n\n\n\n\n&#x2F;&#x2F;浮雕贴图\nfloat2 ReliefMapping(float2 uv, real3 viewDirTS)\n&#123;\n    float2 offlayerUV &#x3D; viewDirTS.xy &#x2F; viewDirTS.z * _HeightScale;\n    float RayNumber &#x3D; 20;\n    float layerHeight &#x3D; 1.0 &#x2F; RayNumber;\n    float2 SteppingUV &#x3D; offlayerUV &#x2F; RayNumber;\n    float offlayerUVL &#x3D; length(offlayerUV);\n    float currentLayerHeight &#x3D; 0;\n    \n    float2 offuv&#x3D; float2(0,0);\n    for (int i &#x3D; 0; i &lt; RayNumber; i++)\n    &#123;\n        offuv +&#x3D; SteppingUV;\n\n        float currentHeight &#x3D; tex2D(_HeightMap, uv + offuv).r;\n        currentLayerHeight +&#x3D; layerHeight;\n        if (currentHeight &lt; currentLayerHeight)\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    float2 T0 &#x3D; uv-SteppingUV, T1 &#x3D; uv + offuv;\n\n    for (int j &#x3D; 0;j&lt;20;j++)\n    &#123;\n        float2 P0 &#x3D; (T0 + T1) &#x2F; 2;\n\n        float P0Height &#x3D; tex2D(_HeightMap, P0).r;\n\n        float P0LayerHeight &#x3D; length(P0) &#x2F; offlayerUVL;\n\n        if (P0Height &lt; P0LayerHeight)\n        &#123;\n            T0 &#x3D; P0;\n\n        &#125;\n        else\n        &#123;\n            T1&#x3D; P0;\n        &#125;\n\n    &#125;\n\n    return (T0 + T1) &#x2F; 2 - uv;\n&#125;\n\n視差閉塞貼圖（POM &#x3D; Parallax Occlusion Mapping）\n視差閉塞貼圖是陡峭視差映射的另一個改進版本。\n相對於浮雕貼圖，不同之處在於最後一步\n浮雕貼圖是在確認最後步進之後進行二分查找（在迭代次數比較多的情況下，還是挺耗的）\n視差閉塞貼圖是在最後步進的兩端uv值進行採樣（下圖紅色箭頭），採樣之後再對這兩個結果進行插值，插值的結果作為P點最終的偏移值\n視差遮蔽映射可以使用相對較少的採樣次數產生很好的結果。但視差遮蔽映射比浮雕視差映射更容易跳過高度圖中的小細節，也更容易在高度圖數據產生大幅度的變化時得到錯誤的結果。\n\n\n優點：\n相對於浮雕映射，性能更好（最後只做插值，而浮雕要做二分查找）\n相對於陡視差貼圖，精確性更好\n\n\n要求：\n因為最後要做插值，所以要求表面是相對比較平滑&#x2F;連續的，如果有莫名的凸起結果可能會出錯\n\n\n\n\n&#x2F;&#x2F;&quot;视差遮蔽贴图&quot;\nvec2 parallaxOcclusionMapping(vec2 uv, vec3 viewDir) \n&#123;\n\tfloat layerDepth &#x3D; 1.0 &#x2F; ubo.numLayers;\n\tfloat currLayerDepth &#x3D; 0.0;\n\tvec2 deltaUV &#x3D; viewDir.xy * ubo.heightScale &#x2F; (viewDir.z * ubo.numLayers);\n\tvec2 currUV &#x3D; uv;\n\tfloat height &#x3D; 1.0 - textureLod(sNormalHeightMap, currUV, 0.0).a;\n\tfor (int i &#x3D; 0; i &lt; ubo.numLayers; i++) &#123;\n\t\tcurrLayerDepth +&#x3D; layerDepth;\n\t\tcurrUV -&#x3D; deltaUV;\n\t\theight &#x3D; 1.0 - textureLod(sNormalHeightMap, currUV, 0.0).a;\n\t\tif (height &lt; currLayerDepth) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tvec2 prevUV &#x3D; currUV + deltaUV;\n\tfloat nextDepth &#x3D; height - currLayerDepth;\n\tfloat prevDepth &#x3D; 1.0 - textureLod(sNormalHeightMap, prevUV, 0.0).a - currLayerDepth + layerDepth;\n\treturn mix(currUV, prevUV, nextDepth &#x2F; (nextDepth - prevDepth));\n&#125;\n\n課後作業\n嘗試使用Shaderlab還原法線映射、視差映射、浮雕映射吧\n除了以上的Mapping，還有別的Mapping嗎? (提高!)\n閱讀此文章，嘗試自己在UE或者Unity引擎中製作冰塊效果吧\n\n提高內容\n材質和BRDF\n更好的光線傳播\n非表面模型\n表面模型\n細節模型\n\n\n\n材質和BRDF更好的光線傳播非表面模型表面模型細節模型\n\n參考資料\nVulkan_法线映射、视差映射、陡视差映射和视差遮挡映射\nInteractive Graphics 19 - Bump, Normal, Displacement, and Parallax Mapping\nUnityShader 基础（54）表面内部空间映射（InteriorMapping）1基础\nInteriorMapping 和 Parallax Mapping 不太一樣，可以寫一次試試看\n\n\n【展示】Unity3D瞳孔渲染效果展示\n《Real-Time Rendering 3rd》 提炼总结(五) 第六章 · 纹理贴图及相关技-毛星云\nUE4材质视差算法\n“Shaders” Gwent Parallax Card Mockup Sketch\n\n","slug":"GraphicQuest/GQ007 材質和外觀","date":"2022-12-15T02:51:05.846Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"fad4f0ed74e380a79d525b4843f7354d","title":"LDR和HDR","content":"LDR和HDRDR: Dynamic Range 最高的亮度和最低的亮度的比值\nLDR: Low Dynamic Range\nHDR: High Dynamic Range\nLDR\n8位精度 (0~255)\n單通道0-1\n格式: PNG, JPG\n應用: 色板，圖片，電腦屏幕\n\nHDR\n大於8位精度 (更加細膩的顏色像素)\n單通道大於1 (可以存儲RGBA以外的圖像信息)\n格式: HDR, TIF, EXR, RAW\n應用: HDRI, 真實世界\n好處: 防止畫面過曝，製作光暈效果\n\n\nToneMappingHDR -&gt; LDR 的過程\n提高內容光場概念\n\n\n\n\n課外練習\n在 Unity 中實現HDR設置\n閱讀關於 Tone mapping 的文章\n\n解答(只含題1):\n\n\nHDR設置 (Unity)\n\n\n參考Tone mapping进化论\n","slug":"GraphicQuest/GQ006 LDR和HDR","date":"2022-12-15T02:51:05.841Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"49a7cda1ef4bef3570774e1eafffcfe0","title":"免費／付費美術資源地址整合","content":"免費／付費美術資源地址整合\nUnity 官方商店\n免費和付費\n各類資源\n\n\nUnreal 官方商店\n免費和付費，\n每月都會免費放出一些收費素材(記得白嫖)\n各類資源\n\n\nDAZstudio \nDAZstudio全稱Digital Art Zone studio\nDazStudio主要是藉用Dazshop（官方產品商城）Renderosity,Renderotica（第三方產品商城 R18 R18-G素材居多）和其他一些零零碎碎第三方資源網站的original等等龐大的模型庫來製作3D數字藝術的。強烈推薦zonegfx\nDaz並不是一款建模軟件，你可以把它認為是更自由更專業的《閃耀暖暖》。\n就算你對3D藝術領域一竅不通，你也能在很短的一段時間內創作出自己的作品。更無需什麼建模知識，也不需要被雜七雜八太過於復雜的渲染器各項參數困擾。 （當然，如果你想在Daz裡玩出花來就必須要對這些知識進行全面的了解）\n正如此軟件的介紹一樣，免費的Daz Studio被初學者和專業人士使用，可以創作出震撼的3D藝術。當然你也可以把它作為繪畫的人體，透視參考。]\n如果有興趣一起學daz或者拿daz模型可以找我\n簡單入門和簡介\n[Daz Studio] Top 5 things to STOP paying for right now!!\n【Blender】【DAZ】【MD】三维辅助流程（完整版）\n超级方便，新手必学一键制作DAZ次世代角色\n\n\nARTSTATION\n免費和付費\n各類資源\n本身網站也很不錯，對於提升審美有很大的幫助\n\n\nOpenGameArt\n免費\n各類資源\n風格較為複古\n\n\nThe Spriters Resource\n免費\n2D素材，大多像素風\n\n\nCraftPix\n免費和付費\n2D素材，各類風格\n\n\nKenney Home\n免費和付費\n2D、3D、Audio、UI\n多是極簡風格\n\n\ntextures\n免費\n寫實類模型及貼圖\n\n\nPoly Haven\n免費\n寫實類模型及貼圖\n\n\nPBRMAX\n收費\n寫實類模型、貼圖，有中國特有的工藝製品、設施建築、百貨。\n\n\nMixamo\n免費，需登錄\n3D角色動畫及模型\n\n\nHumble Bundle\n收費\n捆綁出售遊戲開髮素材、工具，以及一些教程資料\n\n\nGame-icons\n免費\n遊戲圖標，各類風格\n\n\nItch\n免費和付費\n各類素材\n獨立遊戲開發者聚集地\n\n\n80LV\n付費\n各類素材、教程、開發工具\n獨立遊戲開發者聚集地\n\n\nOpen Source Game Clones\n開源\n各種老遊戲的開源重製版本\n想要復刻某款遊戲可以參考代碼、\n借用美術素材\n\n\nNvlMaker 共享素材站\n免費\n視覺小說素材\n\n\nVroid Hub\n免費\n用於VR、MMD、虛擬主播等的人物模型，二次元風格\n\n\nposemaniacs\nline of action\nSketchfab\nkamitokatachi\nQuickposes\nBODIES IN MOTION\n\n","slug":"art_asset","date":"2022-12-14T14:00:28.000Z","categories_index":"美術資源","tags_index":"Art","author_index":"tom_ci"},{"id":"d19b343b2530697581da27d289c3281f","title":"神寄的ASCII碼","content":"支線任務2神寄的ASCII碼在以下代碼中，在strig[]中字符數組中，存放著’→’，目標是輸出當前符號的ASCII碼\n解釋一下為何strig[]明明只存在一個符號，卻可以輸出兩個完全不一樣的ASCII碼?\nint main()\n&#123;\n    char strig[] &#x3D; &quot;→&quot;;\n    &#x2F;&#x2F;ASCII碼\n\n    for (int i &#x3D; 0; i &lt; strlen(strig); i++)\n    &#123;\n        cout &lt;&lt; &quot;strig[]有: &quot; &lt;&lt; int(strig[i]) &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; &quot;→的ASCII: &quot; &lt;&lt; int(&#39;→&#39;) &lt;&lt; endl;\n&#125;\nstrig[]有: -95\nstrig[]有: -6\n→的ASCII: 41466\n\n解答因為’→’占用了兩個字節的內存空間，而普通的a~Z英文字母只占一個字節\n‘→’ 在網上查詢Unicode編碼可以得知其為:\\u2192\n在過去為了在電腦上表達多國語言以及更多符號，製定了一個又一個格式不一的字符集，Unicode編碼便是其中之一，它同時也是ascii碼表的超集。\n在VS裡的工程文件中，新手經常忘記調整屬性頁面上的字符集設定，使用多位元組字元集和使用Unicode字元集兩個的程序設計是有很大的差異的。\n在別的編程語言中可能不會見到此類問題，但是對於Window編程來說，這會關係到你的程式是否支持顯示多種語言的問題!\n","slug":"C++SideQuest/SQ002 神寄的ASCII碼","date":"2022-12-14T14:00:28.000Z","categories_index":"C/C++筆記","tags_index":"C++","author_index":"tom_ci"},{"id":"db49cb760e7bb4ed8d0d9d5c7a050118","title":"基於複製的瞬間移動","content":"支線任務3基於複製的瞬間移動\n\n\n\n\n\n\n\n\n忒修斯之船如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？\n我們來重新複習c++裡的構造函數，來定義一個班級Class吧\nenum GENDER&#123;\n    Male,\n    Female\n&#125;;\n\nclass Student&#123;\n    std::string id_; &#x2F;&#x2F;學號\n    std::string name_; &#x2F;&#x2F;名字\n    GENDER gen_; &#x2F;&#x2F;性別\n&#125;;\n\nclass StClass&#123;\n    Student stu_[5]; &#x2F;&#x2F;五個人的班級\n&#125;;\n\nStClass class_A; &#x2F;&#x2F; 構造班級A\n\n太好了，假設我們已經把班級A裡的學生以及他們的屬性都設定好了\n現在我想要把班級A裡的學生移動到新建立的班級B，要怎麼做呢?\n那不簡單嗎?直接寫個新的class構造函數不就好了\nclass StClass&#123;\npublic:\n    StClass(const StClass&amp; r)\n    &#123;\n        for (size_t i &#x3D; 0; i &lt; 5 ; ++i)\n        &#123;\n            stu_[i] &#x3D; r.stu_[i];\n        &#125;\n    &#125;\n    Student stu_[5]; &#x2F;&#x2F;五個人的班級\n&#125;;\n\nStClass class_A; &#x2F;&#x2F; 構造班級A\n&#x2F;&#x2F;... 設定屬性\nStClass class_B(class_A); &#x2F;&#x2F; &quot;移動&quot;班級A到班級B\n\n有注意到我們是怎麼”移動”班級A的同學到班級B的嗎?\n解答實際上現在在班級B裡的同學全部都是班級A同學的”複製人”，這樣的構造函數我們稱作copy constructor。\n那麼怎麼和編譯器說我們是真的要搬移一個物件的內容而不是複製呢?我們可以使用 C++11 中的 Move semantics 和 右值引用 來進行實現搬移操作\n以後想要移動目標數據就再也不需要先複製一份數據再輸出出去了!\nclass StClass&#123;\npublic:\n    &#x2F;&#x2F;move constructor\n    StClass(const StClass&amp;&amp; r)\n    &#123;\n        for (size_t i &#x3D; 0; i &lt; 5 ; ++i)\n        &#123;\n            stu_[i] &#x3D; std::move(r.stu_[i]);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;copy constructor\n    StClass(const StClass&amp; r)\n    &#123;\n        for (size_t i &#x3D; 0; i &lt; 5 ; ++i)\n        &#123;\n            stu_[i] &#x3D; r.stu_[i];\n        &#125;\n    &#125;\n    Student stu_[5]; &#x2F;&#x2F;五個人的班級\n&#125;;\n\nStClass class_A; &#x2F;&#x2F; 構造班級A\n&#x2F;&#x2F;... 設定屬性\nStClass class_B(std::move(class_A)); &#x2F;&#x2F; 移動班級A到班級B\n\n\n備忘可以前往SideQuestCode資料夾找到示例代碼\n","slug":"C++SideQuest/SQ003 基於複製的瞬間移動","date":"2022-12-14T14:00:28.000Z","categories_index":"C/C++筆記","tags_index":"C++","author_index":"tom_ci"},{"id":"328642e73045afd436ec2a938d320e13","title":"i++和++i哪個快?","content":"支線任務1i++和++i哪個快?i++ : 後加\n++i : 前加\n你知道對於電腦來說，哪個更快嗎?\n解答在這兩個簡單函數中，寫出前加和後加的分別:\nvoid fun_1()\n&#123;\n    int i &#x3D; 1;\n    int a &#x3D; ++i;\n&#125;\n\nvoid fun_2()\n&#123;\n    int i &#x3D; 1;\n    int a &#x3D; i++;\n&#125;\n\n而如果在編譯器的角度來看，它們的匯編指令為:\nfun_1():\n        push    rbp\n\n        #(int i &#x3D; 1;)\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], 1 \n\n        #(int a &#x3D; ++i;)\n        add     DWORD PTR [rbp-4],\n        mov     eax, DWORD PTR [rbp-4]\n        mov     DWORD PTR [rbp-8], eax\n\n        nop\n        pop     rbp\n        ret\nfun_2():\n        push    rbp\n\n        #(int i &#x3D; 1;)\n        mov     rbp, rsp \n        mov     DWORD PTR [rbp-4], 1\n\n        #(int a &#x3D; i++;)\n        mov     eax, DWORD PTR [rbp-4]\n        lea     edx, [rax+1]\n        mov     DWORD PTR [rbp-4], edx\n        mov     DWORD PTR [rbp-8], eax\n\n        nop\n        pop     rbp\n        ret\n\n如果不懂匯編代碼也沒有關係，只知道越少指令行效率越快就可以了(沒有循環的話)\n注意到: fun_1 和 fun_2 之間的分別多了一行匯編碼\n因此在對比++i和i++的效率的時候，我們可以說++i比i++更好\n那多出來的匯編碼是甚麼?\n前加:\n\nDWORD PTR [rbp-4] ``` 很容易理解\n2. 後加:\n\n&#96;&#96;&#96; lea     edx, [rax+1] &#96;&#96;&#96; 先實現自加1的運算，然後放在臨時變量edx中(1+1 &#x3D; 2，現在edx中存放著2)\n\n&#96;&#96;&#96; mov     DWORD PTR [rbp-4], edx&#96;&#96;&#96; 把臨時變量edx 拷貝複製給了變量i\n\n# 為何後加要增加多一個臨時變量再拷貝複製?\n\n因為i++的返回值2是右值型的，右值的臨時變量只能夠給別人賦值\n\n而++i是左值型的，左值可以被直接賦值\n\n在看看另外一個例子:\n&#96;&#96;&#96;c++\nvoid fun_3()\n&#123;\n    int i &#x3D; 1;\n    ++i &#x3D; 2; #可以把2賦值給&quot;左值&quot;\n    i++ &#x3D; 2; #不能把2賦值給&quot;右值，編譯器無法編譯\n&#125;\n\n即便多了一行匯編碼，這差距也很小不是嗎?正確的，現代CPU一秒可以運行幾百萬行指令，這兩個幾乎沒有差別，在int類型你喜歡用哪個就用哪個。\n不過對於別的類型來說，當我們需要實現一個class對象的自增，前加的效率會比後加的效率來得高。比如我們製作出一隻怪物，想要讓怪物npc對象自增，那麼在後加的過程就會需要一系列的臨時變量來紀錄怪物的血量，攻擊力，防禦力等等，那就不會是幾節內存能搞定的事情了。\n備忘https://godbolt.org/\n","slug":"C++SideQuest/SQ001 i++和++i哪個快","date":"2022-12-14T14:00:28.000Z","categories_index":"C/C++筆記","tags_index":"C++","author_index":"tom_ci"},{"id":"0b051e637dda72e2ba4a48d953610695","title":"速通LeetCode水題一百道","content":"速通LeetCode水題一百道刷完這下面的99道Leetcode題，就算入門C++&#x2F;Python了(leetcode.cn)\n\n2235. 两整数相加\n剑指 Offer II 072. 求平方根\n69. x 的平方根\n367. 有效的完全平方数\n剑指 Offer 16. 数值的整数次方\n50. Pow(x, n)\n231. 2 的幂\n326. 3 的幂\n342. 4 的幂\n面试题 16.01. 交换数字\n面试题 08.05. 递归乘法\n2119. 反转两次的数字\n剑指 Offer 58 - II. 左旋转字符串\n面试题 16.07. 最大数值\n1812. 判断国际象棋棋盘中一个格子的颜色\n136. 只出现一次的数字\n268. 丢失的数字\n剑指 Offer 53 - II. 0～n-1中缺失的数字\n1486. 数组异或操作\n1009. 十进制整数的反码\n476. 数字的补数\n剑指 Offer 15. 二进制中1的个数\n191. 位1的个数\n461. 汉明距离\n2220. 转换数字的最少位翻转次数\n1342. 将数字变成 0 的操作次数\n1492. n 的第 k 个因子\n2006. 差的绝对值为 K 的数对数目\n1929. 数组串联\n1108. IP 地址无效化\n\n\n","slug":"C++SideQuest/SQ005 速通LeetCode水題一百道","date":"2022-12-14T14:00:28.000Z","categories_index":"C/C++筆記","tags_index":"C++","author_index":"tom_ci"},{"id":"58cce547e2f24b99cce315d0703eb5c7","title":"COM架構","content":"COM架構COM架構，元件物件模型（英語：Component Object Model，縮寫COM）\n其實可以當成是一個普通的c++類，只不過COM架構更加具體且擁有統一的定義\n在學習Direct3D的時候經常可以看見以大寫字母“I”為前綴COM接口。例如，表示2D紋理的接口為ID3D11Texture2D\n所以在使用COM接口的時候，注意要使用其原有自帶的獲取和釋放方法，不要使用new 和delete\n細節還有很多，只需要知道其特殊性和存在就可以了\n","slug":"C++SideQuest/SQ004 COM架構","date":"2022-12-14T14:00:28.000Z","categories_index":"C/C++筆記","tags_index":"C++","author_index":"tom_ci"},{"id":"9969c9a42c025437ce5d231d56edb863","title":"模型格式和材質","content":"GQ002 模型格式和材質OBJ文件OBJ文件是一種被廣泛使用的3D模型文件格式（obj為後綴名）。由Alias|Wavefront公司為3D建模和動畫軟件”Advanced Visualizer”開發的一種標準，適合用於3D軟件模型之間的互導，也可以通過3dsmax、Maya等建模軟件讀寫。\n重點:\n\nv（vertex）数据段: 模型顶点列表\nvt（vertex texture）数据段：模型顶点的纹理坐标列表\nvn（vertex normal）数据段：顶点法线列表\nf（face）：模型的三角面列表\n紋理座標 (UV座標)\n\nOBJ文件格式:# &quot;#&quot;号开头是注释行\n# v（vertex）数据段: 模型顶点列表\n# 顶点位置信息，是xyz三维坐标\n# v开头的每一行描述一个顶点，行数等于顶点数。8个顶点所以有8行\nv  1.00  -1.00  -1.00\nv  1.00  1.00  1.00\n......\n# vt（vertex texture）数据段：模型顶点的纹理坐标列表\n# 顶点的纹理坐标信息，是xy二维坐标\n# vt开头的每一行描述一个纹理坐标，行数大于等于顶点数，因为一个模型顶点在贴图的UV坐标系中很可能对应多个顶点&#x2F;纹理坐标。且坐标值范围是在0~1之间，这个模型中有14行。\n# 关于纹理坐标，本文不多解释纹理坐标，就是UV座標\nvt  0.74  0.75\nvt  0.29  0.55\n......\n# vn（vertex normal）数据段：顶点法线列表\n# 三维法向量，xyz\n# vn开头的每一行描述一个法向量，行数大于等于顶点数。 前面介绍了，法线是与面相关的概念，但是现在的面是靠顶点来描述，拿点&quot;1&quot;为例，它与参与构成了三个面，所以&quot;顶点1&quot;对应有3条法线\n# 可能你已经发现了，在这个立方体模型中，共面顶点的法向量的方向是相同的，也就是说这里面的数据会重复，所以在建模软件导出obj文件时有个优化的选项，勾选后的导出的法线列表数据中就不会有重复项，这里的例子优化后有6条法线*\nvn  -1.00 0.00 0.00 \nvn  1.00 0.00 0.00\nvn  0.00 1.00 0.00\n......\n# f（face）：模型的三角面列表\n# f开头的每一行描述一个面 ，关键的来了，三个点组成一个面，怎样拿到这三个点呢？通过从1开始的索引，去前面的v、vt、vn列表中去取。\n# 总结一下就是：每一行定义1个面，1个面包含3个点，1个点具有“顶点&#x2F;纹理坐标&#x2F;法线”3个索引值，索引的是前面3个列表的信息。\nf  1&#x2F;1&#x2F;1  2&#x2F;2&#x2F;1  3&#x2F;3&#x2F;1      # 顶点1、顶点2、顶点3 组成的面\nf  2&#x2F;2&#x2F;1  3&#x2F;3&#x2F;1  4&#x2F;4&#x2F;1      # 顶点2、顶点3、顶点4 组成的面\nf  1&#x2F;1&#x2F;1  5&#x2F;10&#x2F;1  8&#x2F;14&#x2F;6  # 顶点1、顶点5、顶点8 组成的面\n......\n以上便是obj 文件的核心部分，此外還有一些數據段，記錄如下。\n\no 對象名\ng 組名\ns 平滑組\nusemtl 材質名\nmtllib 材質庫.mtl\n\n由於Obj文件和mtl文件是息息相關的，這裡留下mtl文件格式供你自行研究\n\n更加詳細mtl文件格式\n\n在model&#x2F;文件下存放著一些obj格式文件(找了很久卻網上沒有的模型)，你也可以參考一下!\nFBX格式和OBJ格式差不多，可以儲存更多類型的信息，是更加通用的文件格式，比如:\n\n動畫\n材質特性\n貼圖\n骨骼動畫\n燈光\n攝像機\n頂點顏色\n等等…\n\n提高內容:\n材質 反射光 光滑組\n\n材質在現實世界中不存在完美的表面，一個模型能攜帶的法線也有限。因此可以使用漫反射，高光，折射等計算去調整法線，也就能影響光照計算的結果\n反射光在現實世界中，每個物體都會對光產生不同的反應，例如:\n\n有些物體反射光的時候不會產生太多的散射(Scatter)，而是產生一個較小的高光點\n有些物體則散射較多，產生一個更大半徑的高光點\n\n反射光類型\n漫反射: 將入射光線均勻地反射出去 (Lambertian 模型)\n鏡面反射: 將入射光線根據表面法線進行反射，且只有在反射方向有能量，其他方向能量則為0\n折射: 根據折射率折射一部分光線進入物體之中\n粗糙鏡面反射: 光線偏移較小，反射集中於一個區域內\n粗糙鏡面折射: 光線偏移較小，反射和折射集中於一個區域內\n多層材質: 多個物體反射(表面一層)出來的投影\n次表面散射: 在半透明的物體內多次反射，多出現於半透明的物體 (玉石，牛奶，皮膚(通常有三層))\n\n頂點顏色小技巧\n最常用的：作為一種存儲的mask使用（這樣可以少使用一張圖）\n\n\n不想讓臉上有菲涅爾效應，就把臉塗黑，乘上頂點色\n不想讓某些地方有描邊，可以如法炮製\n想把其它信息塞入頂點色。\n\n\n可用於預先指定照明、阻光和其他視覺效果。\n把顏色信息存在頂點裡，但在低模的情況下效果很差。(塞入頂點色的信息必須是線性變化的，如果不是，就要做好精度打折的準備)\n\n\n3ds Max 顶点颜色\n\n3ds Max 中的所有對像都具有貼圖通道，其中保存關於紋理貼圖以及頂點顏色、照明和 Alpha 的信息。網格對象同樣具有幾何體和頂點選擇通道。\n\n\n\n\n\n\n\n\n\n主通道為頂點顏色，這可以使對像中的每個頂點都有其自己的顏色，並且在頂點之間自動漸變。此著色默認情況下不可見，但您可以通過“對象屬性”設置切換其顯示。還可以通過“頂點繪製”修改器等各種功能查看和編輯頂點著色。它可用於預先指定照明、阻光和其他視覺效果。貼圖通道數據也可由如游戲引擎等外部應用程序使用\n光滑組光滑組（smoothing group）是用來設置邊緣線的光滑顯示的。\nsmoothing group定義了模型邊緣被渲染出來的方式，下圖三個瓶子是同一個模型。左邊的瓶子是硬邊渲染出來的。右邊的瓶子就是光滑的邊緣渲染出來的。中間的瓶子在高光區域設置了smoothing group，所以高光區是平滑的，而其他邊緣仍然是硬邊渲染\n\n下面圖標出了面的亮度(不是確切數字)，兩面之間的過渡就是兩面亮度和的平均值，光滑組處理面之間的光照信息，提高它們的亮度、飽和度\n\n\n如果兩個面一個光滑組是1，另一個是2，就不進行計算\n如果他們的光滑組都是1，就會進行光照計算，產生光滑效果，影響最終渲染\n\n\n光滑組和法線使用Substance Painter軟件製作漸變色的法線貼圖的時候，會出現黑邊情況\n\n光滑組相連的模型，法線貼圖都存在大漸變色，導致模型的法線效果會很奇怪（平面上有發暗發亮的光影）。當你發現你的模型出現這種漸變時，一定是出現了光滑組的問題。\n中間的兩個模型出現了不同程度的接縫（第三個模型的接縫非常明顯，第二個模型則弱一些）。光滑組和uv統一相連或斷開，是不會出現明顯接縫的，當遇到接縫問題，優先考慮模型的光滑組和uv是否統一\n\n\n紋理動畫在採樣紋理的時候，可以嘗試把紋理的圖片UV座標平移，達到產生複雜動畫的錯覺\n\n\n備忘https://www.adobe.com/products/substance3d-painter.html\n","slug":"GraphicQuest/GQ002 模型格式和材質","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"364a4cad820c2b7aa61aea1e7f6bce5d","title":"HLSL 入門和基本函數","content":"HLSL 入門和基本函數什麼是HLSL？\n高階著色器語言（High Level Shader Language，簡稱HLSL），就是用來編寫shader的一種語言\n類似的語言還有：\nCG它是由NVIDIA公司所開發的，基於C語言同時被OpenGL和Direct3D所支持的開發語言，其語法和HLSL類似。在《GPU編程與CG語言之陽春白雪》中雖然曾認為CG會越來越受歡迎，但遺憾的是，NVIDIA還是拋棄了CG，目前CG的最終版本是3.1。雖然在一些簡單的shader編寫上還是可以使用，但是在新的硬件環境下還是可能不支持，且對一些新功能的支持較差。\nGLSLGLSL是基於OpenGL的接口，其語法體係自成一家。但是它不支持DirectX，就不得不放棄僅支持DirectX的Xbox等平台。\nHLSLHLSL是由微軟開發的，在Windows平台上一家獨大，多用於遊戲領域。語法類似CG語言，在Unity中CG和HLSL等價。\n常用函數分類\n基本數學運算\n冪指對函數\n數據範圍類\n類型判斷類\n三角函數與雙曲線函數\n向量與矩陣類\n光線運算類\n1D紋理查找\n2D紋理查找\n3D紋理查找\n立體紋理查找\n\n基本數學運算| 函數名 | 用途|——\t|——-| max（a，b） | 返回較大的 || min（a，b） |\t返回較小的 || mul（a，b） | 兩向量相乘，常用於矩陣運算 || abs（a）\t  | 返回a的絕對值 || round（x）  | 返回與x最近的整數 || sqrt（x）\t  | 返回x的平方根 || rsqrt（x）  | 返回x的平方根的倒數 || degrees（x）| 將弧度轉化為角度 || redians（x）| 將角度轉化為弧度 || noise（x）  | 噪聲函數,在每個像素點上輸出0&#x2F;1可形成噪波圖 |\n冪指對函數| 函數名 | 用途 | 數學式|——\t|——- |——-| pow（x，y） | x的y次冪（x、y都可以是自變量或具體數）| $x^{y}$ || exp（x）| 返回以e為底的指數函數 | $e$ || exp2（value x）|\t返回以2為底，x為指數的冪 | $2^{x}$ || ldexp（x，exp）|\t返回與2的exp次方的乘積 | $x2^{exp}$ || log（x）|\t返回指定值的以e為底數的對數 | $lnx$ || log10（x）| 求以10為底的對數 | $log_{10}x$ || log2（x）\t| 求以2為底數的對數 | $log_{2}x$ || frexp（x，out exp）|\t將浮點數分解成尾數和指數，x的返回值是尾數,exp參數返回的值是指數（加上out會返回exp和規格化小數）| $x&#x3D;ret2^{exp}$ |\n類型判斷類| 函數名 | 用途|——\t|——-|ceil（x）|\t返回&gt;&#x3D;x的最小整數（向下取整）|floor（x）|\t返回&lt;&#x3D;x的最大整數（向上取整）|step（x，y）|\tx&lt;&#x3D;y返回1（真），否則返回0|saturate（x）|\t返回將x箝制到[0,1]範圍之間的值|clamp（x，min，max）|\t將x限制在[min，max]範圍的值，比min小返回min，比max大返回max|fmord（x，y）|\t返回x對y取餘的餘數|frac（x）|\t取x的小數部分|modf（x，out ip）|\t將x分為小數和整數部分（輸出的ip為整數部分，返回值為小數部分）|lerp（x，y，s）|\t按照s在x到y之間插值，返回|smoothstep（min，max，x）|\t如果x在[min，max]範圍內，就返回介於[0，1]之間的平滑Hermite插值，使用smoothstep在兩個值創建平滑過渡， 例如平滑地混合兩種顏色\n三角函數與雙曲線函數| 函數名 | 用途|——\t|——-|sin（x）、cos（x）、tan（x）|三角函數（弧度製：$1°&#x3D;π&#x2F;180 rad$）|asin（x）、acos（x）、atan（x）|\t反三角函數|sincos（x，out s，out c）|\t返回x的正弦和余弦|tan（y，x）|\t返回$y&#x2F;x$的正切|atan2（y，x）|\t返回$y&#x2F;x$的反正切|sinh（x）|\t返回$x$的雙曲正弦值|cosh（x）|\t返回$x$的雙曲餘弦值|tanh（x）|\t返回$x$的雙曲正弦值\n向量與矩陣類| 函數名 | 用途|——\t|——-|length(v)|\t返迴向量的長度|normalize(v)|\t向量歸一化，x&#x2F;length(x) 方向向量歸一化|distance(a,b)|\t返回兩個向量之間的距離，不平行的兩個向量應該為0，此處表示為根號下各分量之差的平方和|dot(a,b)\t|返回a和b兩向量的點積|cross(a,b)|\t返回a和b兩向量的叉積，返回值是向量，並且與a,b都垂直|determinant(m)\t|返回指定浮點矩陣的按行列式方式計算的值|transpose(m)|\t返回矩陣m的轉置矩陣\n光線運算類| 函數名 | 用途|——\t|——-|reflect(i,n)| 以i為入射向量n為法線方向的反射光|refract(i,n,ri)|\t以i為入射向量n為法線方向,ri為折射率的折射光|lit(n_dot_l,n_dot_h，m)|\t輸入標量(normal,light,半角向量h,鏡面反射係數m) 返迴光照向量(環境光，漫反射光，鏡面高光反射，1)該計算依據的是BlingPhong光照模型|faceforward(n,i,ng)|\t得到面向視圖方向的曲面法向量輸入輸出為同元向量,返回-n*sign(dot(i,ng))(normal,light,normal)\n紋理查找紋理查找就是GPU在片元處理階段中在屏幕空間的XY坐標系中對每一個像素對應的紋理查找對應的紋素來確定像素的顏色\n1D紋理其實就是一條線，可看做一維數組，2D可看做二維數組（面），3D三維（體）\n1D紋理查找 (幾乎不用)| 函數名 | 用途|——\t|——-|tex1D(s, t)|\t普通一維紋理查找 返迴紋理採樣器s在標量t位置的color4|tex1D(s,t,ddx,ddy)|\t使用微分查詢一維紋理， t和ddxy均為vector|tex1Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4|tex1Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的一維紋理查找|tex1Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的一維紋理查找|tex1Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢\n2D紋理查找| 函數名 | 用途|——\t|——-|tex2D(s, t)|\t普通二維紋理查找 返迴紋理採樣器s在vector t位置的顏色|tex2D(s,t,ddx,ddy)|\t使用微分查詢二維紋理，t和ddxy均為vector|tex2Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4|tex2Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的二維紋理查找|tex2Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的二維紋理查找|tex2Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢\n3D紋理查找| 函數名 | 用途|——\t|——-|tex3D(s, t)|\t普通三維紋理查找 返迴紋理採樣器s在vector t位置的顏色|tex3D(s,t,ddx,ddy)|\t使用微分查詢三維紋理， t和ddxy均為vector|tex3Dlod(s, t)|\t使用LOD查找紋理s在t.w位置的color4|tex3Dbias(s, t)|\t將t.w決定的某個MIP層偏置後的三維紋理查找|tex3Dgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的三維紋理查找|tex3Dproj(s, t)|\t把紋理當做一張幻燈片投影到場景中，先使用投影紋理技術需要計算出投影紋理坐標t(坐標t.w除以透視值)，然後使用投影紋理坐標進行查詢\n立體紋理查找| 函數名 | 用途|——\t|——-|texCUBE(s,t)|\t返迴紋理採樣器s在vector t位置的顏色|texCUBE(s,t,ddx,ddy)|\t使用微分查詢立方體維紋理 ，t和ddxy均為vector|texCUBEDload(s,t)|\t使用LOD查找紋理s在t.w位置的color4|texCUBEbias(s,t)|\t將t.w決定的某個MIP層偏置後的立方體紋理查找|texCUBEgrad(s,t,ddx,ddy)|\t使用微分並指定MIP層的立方體紋理查找|texCUBEproj(s,t)|\t使用投影方式的立方體紋理查找\n著色器導數函數偏導數函數(偏差分導函數)（在HLSL和GLSL中）是片段著色器指令，可用於計算任何值相對於屏幕空間坐標的變化率\n偏導數函數是紋理mipmaps實現的基礎，也能實現一系列算法和效果，特別是哪些依賴於屏幕空間坐標的(比如渲染統一線寬的線框)。\n導數計算 dFdx 和 dFdy (ddx 和 ddy)在三角形光柵化期間，GPU 以 2×2 的 block 片段來計算光柵化，通過取block 中像素值之間的差異來計算導數\n提高內容\n導數計算-續\n\n導數計算-續\ndFdx 從右邊片段中減去左側片段像素值 (右 - 左)\ndFdy 從上邊片段中減去下部片段像素值 (上 - 下)\n下圖其中網格表示渲染的屏幕像素，以紅色突出顯示的 2×2 block 對應的(x, y)屏幕座標\n\n\n示例代碼在Unity中嘗試調用 tex2D ddx ddy 等函數，在&#x2F;Shader下ShaderOfDdx文件裡面有源碼\nShader &quot;Custom&#x2F;ShaderOfDdx&quot;\n&#123;\n    Properties\n    &#123;\n        [KeywordEnum(IncreaseEdgeAdj, BrightEdgeAdj)] _EADJ(&quot;Edge Adj type&quot;, Float) &#x3D; 0\n        _Tex(&quot;Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n        _Intensity(&quot;Intensity&quot;, Range(0, 20)) &#x3D; 2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;\n            Cull off\n            Blend SrcAlpha OneMinusSrcAlpha\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #pragma multi_compile _EADJ_INCREASEEDGEADJ _EADJ_BRIGHTEDGEADJ\n            #include &quot;UnityCG.cginc&quot;\n            struct appdata\n            &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n            struct v2f\n            &#123;\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            &#125;;\n            sampler2D _Tex;\n            float4 _Tex_ST;\n            float _Intensity;\n            v2f vert (appdata v)\n            &#123;\n                v2f o;\n                o.vertex &#x3D; UnityObjectToClipPos(v.vertex);\n                o.uv &#x3D; TRANSFORM_TEX(v.uv, _Tex);\n                return o;\n            &#125;\n            fixed4 frag (v2f i, float f : VFACE) : SV_Target\n            &#123;\n                fixed a &#x3D; 1;\n                if (f &lt; 0) a &#x3D; 0.5;\n                fixed3 c &#x3D; tex2D(_Tex, i.uv).rgb;\n                #if _EADJ_INCREASEEDGEADJ &#x2F;&#x2F; 邊緣調整：增加邊緣差異調整\n                c +&#x3D; (ddx(c) + ddy(c)) * _Intensity;\n                #else &#x2F;&#x2F;_EADJ_BRIGHTEDGEADJ &#x2F;&#x2F; 邊緣調整：增加邊緣亮度調整\n                &#x2F;&#x2F;c +&#x3D; abs(ddx(c)) + abs(ddy(c)) *_Intensity;\n                c +&#x3D; fwidth(c) * _Intensity; &#x2F;&#x2F; fwidth(c) &#x3D;&#x3D;&gt; abs(ddx(c)) + abs(ddy(c))\n                #endif &#x2F;&#x2F; end _EADJ_INCREASEEDGEADJ\n                return fixed4(c, a);\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n\n\n\n使用(ddx(c) + ddy(c))，沒有絕對值，會然邊緣的像素亮度差異變大，即：加強邊緣突出\n使用fwidth函數，可以看出邊緣變亮，突出邊緣 &#x2F;&#x2F; fwidth(c) &#x3D;&#x3D;&gt; abs(ddx(c)) + abs(ddy(c))\n\n\n\n課外練習\n嘗試在 Unity 中編寫 HLSL 代碼吧 (Unity Shaderlab)\n(提高) 試著了解著色器導數函數吧，看看這函數有甚麼奇淫技巧?\n\n備忘\nhlsl-intrinsic-functions\n\nshader-derivative-functions\n\nfwidth func in HLSL\n\n\n","slug":"GraphicQuest/GQ003 HLSL入門和基本函數","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"a993952f98b295ed6db3d1a544a2ca1d","title":"傳統光照模型詳解","content":"傳統光照模型詳解光照模型分類:\n\n基於物理的光照模型（PBR）（有可依據的公式）\n經驗模型（近似、模擬）\n\n局部光照的定義:只考慮光源的影響，不考慮光線多次反射\n（對應的概念：全局光照&#x3D;直接光照+間接光照）\n局部光照模型內容的分類:\n局部光照模型滿足疊加原理，可分為四個部分:\n\n漫反射項 $C_{diffuse}$\n高光項 $C_{specular}$\n環境光項 $C_{ambient}$\n自發光\n\n你可以理解成Photoshop中圖層1,圖層2,…,圖層4疊加而成的光照模型\n漫反射 $C_{diffuse}$光會被均勻的反射到不同的方向\n漫反射過程中，光線發生了吸收和散射，所以顏色和方向發生了改變\nLambert餘弦定律：$C_{diffuse} &#x3D; C_{light} * m_{diffuse} * dot(normal,L)$\n\n\n\n\n\n\n\n\n\n$C_{light}$ 光源強度和顏色\n$m_{diffuse}$ 材質的漫反射率\n$dot(normal,L)$ 物體表面法線和入射光線的點乘\n高光&#x2F;鏡面反射 $C_{specular}$$C_{specular} &#x3D; C_{light} * m_{specular} * dot(v,r)^{m_{gloss}}$\n\n\n\n\n\n\n\n\n\n$C_{light}$ 光源強度和顏色 * dot(v,r)^{m_{gloss}}$\n$m_{specular}$ 材質的高光&#x2F;鏡面反射率\n$dot(v,r)$ 視角方向和反射方向的點乘 (v為視角方向，r為反射方向)\n$m_{gloss}$ 材質的光澤度\n環境光 $C_{ambient}$假設模型在場景中發生多次散射和反射，並均等地射向物體表面\n$C_{ambient} &#x3D; Albedo * Ambient_{light}$\n通常使用的公式:\n$C_{ambient} &#x3D; A_{light} * m_{diffuse}$\n自發光由模型自行發出的光，通常直接使用一張發光貼圖來描述自發光\n發光貼圖的製作可以使用剛剛以上的生成公式 + 一張你喜歡貼圖，達到發光的效果\nLambert 模型只使用Lambert餘弦定律來構造的模型\n成品:$Color &#x3D; C_{light} * m_{diffuse} * dot(normal,L)$\nPhong 模型$C_{ambient} &#x3D; Albedo * Ambient_{light}$\n$C_{diffuse} &#x3D; C_{light} * m_{diffuse} * dot(normal,L)$\n$C_{specular} &#x3D; C_{light} * m_{specular} * dot(v,r)^{m_{gloss}}$\n成品:$Color &#x3D; C_{ambient} + C_{diffuse} + C_{specular}$\nPhong 模型 (附自發光) 完整流程圖\nUnity Shader\nShader &quot;Custom&#x2F;NewSurfaceShader&quot;\n&#123;\n    Properties\n    &#123;\n        _Diffuse(&quot;Diffuse&quot;,color) &#x3D; (1,1,1,1)\n        _Specular(&quot;Specular&quot;,color) &#x3D; (1,1,1,1)\n        _Gloss(&quot;Gloss&quot;,Range(1.0,255)) &#x3D; 20\n        [KeywordEnum(LAMBERT,PH0NG,BLINNN_PH0NG)] _MODE(&quot;MODE&quot;,float) &#x3D; 0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            &#x2F;&#x2F;shader_feature\n            #pragma multi_compile _MODE_LAMBERT _MODE_PH0NG _MODE_BLINNN_PH0NG\n\n\n            #include &quot;UnityCG.cginc&quot;\n            #include &quot;Lighting.cginc&quot;\n            #include &quot;AutoLight.cginc&quot;\n\n            struct appdata\n            &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n                float3 normal : NORMAL;\n            &#125;;\n\n            struct v2f\n            &#123;\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n                float3 normalDir : TEXCOORD1;\n            &#125;;\n\n            v2f vert (appdata v)\n            &#123;\n                v2f o;\n                o.vertex &#x3D; UnityObjectToClipPos(v.vertex);\n                o.uv &#x3D; v.uv;\n\n                &#x2F;&#x2F; 將物體法線從物體坐標系轉換到世界坐標系\n                o.normalDir &#x3D; UnityObjectToWorldNormal(v.normal);\n                return o;\n            &#125;\n\n            float4 _Diffuse;\n            float4 _Specular;\n            float _Gloss;\n\n            fixed4 frag (v2f i) : SV_Target\n            &#123;\n                &#x2F;&#x2F; 法線方向\n                float3 normalDirection &#x3D; normalize(i.normalDir);\n                &#x2F;&#x2F; 燈光方向\n                float lightDirection &#x3D; normalize(_WorldSpaceLightPos0.xyz);\n                &#x2F;&#x2F; 基於蘭伯特模型計算燈光\n                float NdotL &#x3D; max(0,dot(normalDirection,lightDirection)); \n                &#x2F;&#x2F; 燈光顏色\n                float3 lightColor &#x3D; _LightColor0.rgb;\n\n\n                &#x2F;&#x2F; 漫反射&#x2F;方向光\n                float3 diffuse &#x3D; lightColor * _Diffuse.rgb * NdotL;\n\n                &#x2F;&#x2F; 計算燈光衰減\n                &#x2F;&#x2F;float attenuation &#x3D; LIGHT_ATTENUATION(i);\n                &#x2F;&#x2F;float3 attenColor &#x3D; attenuation * _LightColor0.xyz;\n\n                &#x2F;&#x2F; 燈光與材質球表面顏色進行作用\n                &#x2F;&#x2F;float3 texColor &#x3D; tex2D(_MainTex, i.uv).rgb;\n                &#x2F;&#x2F;float3 diffuseColor &#x3D; texColor *(directionDiffuse+inDirectionDiffuse);\n\n                &#x2F;&#x2F; LAMBERT 模型 (只有漫反射)\n                #if defined(_MODE_LAMBERT)\n                    float3 Color &#x3D; diffuse;\n                &#x2F;&#x2F; PHONG 模型 (環境光 + 漫反射 + 高光反射)\n                #elif defined(_MODE_PH0NG)\n                    &#x2F;&#x2F; 環境光  \n                    float3 ambient &#x3D; float3(0,0,0)+UNITY_LIGHTMODEL_AMBIENT.rgb;\n                    &#x2F;&#x2F; 高光反射\n                    &#x2F;&#x2F; 反射光方向 \n                    float3 reflectDir &#x3D; normalize(reflect(lightDirection,normalDirection));\n                    &#x2F;&#x2F; 視角方向\n                    float viewDir &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.normalDir.xyz);\n                    &#x2F;&#x2F; 視角方向和反射光方向的點乘\n                    float vdotR &#x3D; max(0.0,dot(reflectDir,viewDir));\n                    &#x2F;&#x2F; 合成\n                    float specular &#x3D; _LightColor0.rgb * _Specular.rgb * pow(vdotR,_Gloss);\n                    \n                    float3 Color &#x3D; diffuse + ambient + specular;\n                &#x2F;&#x2F; BLINNN_PH0NG 模型 (高光反射使用半程向量)\n                #elif defined(_MODE_BLINNN_PH0NG)\n                    &#x2F;&#x2F; 環境光  \n                    float3 ambient &#x3D; float3(0,0,0)+UNITY_LIGHTMODEL_AMBIENT.rgb;\n                    &#x2F;&#x2F; 高光反射\n                    &#x2F;&#x2F; 視角方向\n                    float viewDir &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.normalDir.xyz);\n                    &#x2F;&#x2F; 計算半角向量\n                    float3 halfDir &#x3D; normalize(lightDirection + viewDir);\n                    &#x2F;&#x2F; 半角向量和光線向量的點乘\n                    float NdotH &#x3D; saturate(dot(halfDir,normalDirection));\n                    &#x2F;&#x2F; 合成\n                    float specular &#x3D; _LightColor0.rgb * _Specular.rgb * pow(NdotH,_Gloss);\n                    \n                    float3 Color &#x3D; ambient + specular + diffuse;\n                #endif\n\n                float4 finalColor &#x3D; float4(Color,1);\n                return finalColor;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n    FallBack &quot;Diffuse&quot;\n&#125;\n\n課外練習\n在Unity實現Phong 模型\n(提高) 完成 GAMES101 Homework3 的作業\n\n參考https://zhuanlan.zhihu.com/p/144331612\n","slug":"GraphicQuest/GQ004 傳統光照模型詳解","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"d0049b73799b979298e1be6a45b168fb","title":"Gamma校正 和 色彩空間","content":"Gamma校正 和 色彩空間現在面臨需要解決的問題和場景:\n\n快速了解Gamma校正\nGamma, Linear, sRGB 這些都是甚麼?\n@橙与青 | 色彩空间为什么那么空？色度系统、色度图、色域、伽马、白点…\n\nCIE RGB人類眼睛有對於短（S, 420-440nm）、中（M, 530-540nm）和長（L, 560-580nm）波長的光感受器（視錐細胞）\n\n\n\n\n\n\n\n\n\n三種視錐細胞最敏感的波長分別是橙紅色（長波，Long），綠色（中波，Medium），藍色（短波，Short）。下圖為三種視錐細胞的歸一化感光曲線\n\n經過實驗以後，人們發現了可以使用三種顏色的光，來混合出現實中的任何一種顏色出來，有以下公式(色匹配函數 Color Matching Function): $C &#x3D; rR + gG + bB$\n\n\n\n\n\n\n\n\n\nrgb分別為三種顏色光源強度\nCIE RGB-&gt; CIE XYZ我們使用了色匹配函數來測試每個人的色匹配函數曲線\n\n\n\n\n\n\n\n\n\n中間深色的粗線代表了數據的平均值\n\n為了解決CIE RGB 色彩空間出現負數的問題，我們設計了一種轉換矩陣M，變換到所有數字都在正數的空間中，這就是CIE XYZ色彩空間\n$$\\begin{bmatrix}    R_{lin} \\    G_{lin} \\    B_{lin}\\end{bmatrix} &#x3D;M *\\begin{bmatrix}    X \\    Y \\    Z\\end{bmatrix}$$\n\n題外話在此基礎下sRGB值還是有可能會回到負值，那麼超出值將會強制歸0(回到sRGB的三角形內)，所以sRGB下的圖像會損失部分準確性\n從CIE XYZ空間轉換後得到了一個線性的RGB值，要令顯示器正常顯示，就要對其使用gamma校正，每個空間的gamma校正公式都不太一樣，用sRGB空間作為例子，就使用了分段函數:\n$$C &#x3D; \\begin{cases}12.92C_{lin},\\quad &amp;x\\leq 0.0031308 \\1.055C_{lin}^{1&#x2F;2.4}-0.055,\\quad &amp;x&gt;0.0031308\\end{cases}$$\n通常的gamma校正公式:\n$$C &#x3D; C_{lin}^{1&#x2F;\\gamma},\\gamma &#x3D;2.2$$\nCIE XYZ 色彩空間CIE XYZ 色彩空間，滿足一些約束條件：\n\n所有坐標都是正的，保持等能點（equal energy point）作為白色\n使得新的 Y 坐標能夠代表明度，也就是使得新的 Y 坐標等於視覺的明度響應\n使得新的 Z 坐標在紅光端保持為 0\n使得所有色彩盡可能充滿新的空間\n\n\n\n\n\n\n\n\n\n\n實際上所有可視顏色的完整繪圖是三維的(你可以發現這裡只有x和y)，CIE 1931色彩空間色度圖。外側曲線邊界是光譜（或單色）光軌跡，波長用奈米標記。注意描繪的顏色依賴於顯示這個圖象的設備的色彩空間，沒有設備能有足夠大色域來在所有位置上提供精確的色度表現\n\n甚麼是Gamma校正灰階分成兩種: \n\n非線性灰階（視覺上看著均勻變化的）\n\n物理&#x2F;線性灰階（物理上均勻變化的）。\n\n\nGamma校正就是把兩者聯繫起來的函數，用來做兩者的轉換。\n\n為什麼要Gamma校正\n人眼對於灰色的變化更敏感\n早期顯示器(CRT)發展需要節能\n\n嘗試在unity 色彩空間使用Gamma校正\n\n\n\n\n\n課外練習\n他們是怎樣設計實驗過程 ? 人類眼睛對不同顏色光線混合的反應是線性的嗎 ?\n\n在色匹配函數中RGB光源強度為0~1之間的數，為什麼匹配函數曲線上出現了負數? (提示: 根據公式: $C &#x3D; rR + gG + bB$ )\n\n已知sRGB 的三原色和白色點XYZ座標\n\n求sRGB 到 XYZ 的轉換矩陣\nXYZ 轉到 sRGB 的轉換矩陣\n\n\n\n\n三原色和白色點\nXYZ座標\n\n\n\nR\n(0.64,0.33,0.03)\n\n\nG\n(0.30,0.60,0.10)\n\n\nB\n(0.15,0.06,0.79)\n\n\nW\n(0.95047,1.00000,1.08883)\n\n\n\n\n解答(只含題3)\n\n\n根據公式: $C &#x3D; rR + gG + bB$\n可以先找到XYZ在新空間的基底向量，我們理想中RGB值為(1,1,1)時將等於白色\n$設w為w_r, w_g, w_b，則w_rR, w_gG, w_bB 為新的基底向量，求w向量$\n$$W &#x3D; w_rR + w_gG + w_bB$$\n$$W &#x3D; [R,G,B]w$$\n$$w &#x3D; [R,G,B]^{-1}W$$\n$$w &#x3D; [R,G,B]^{-1}W &#x3D;\\begin{bmatrix}    0.64&amp;0.30&amp;0.15 \\    0.33&amp;0.60&amp;0.06 \\    0.03&amp;0.10&amp;0.79\\end{bmatrix}^{-1}\\begin{bmatrix}    0.95047 \\    1.00000 \\    1.08883\\end{bmatrix} &#x3D;\\begin{bmatrix}    0.6445 \\    1.1919 \\    1.2029 \\\\end{bmatrix}$$\n$以w_rR, w_gG, w_bB 為新的基底向量，找出在C_{XYZ}它所對應的sRGB座標$\n$$1式:\\begin{bmatrix}    X \\    Y \\    Z\\end{bmatrix} &#x3D;M *\\begin{bmatrix}    R_{lin} \\    G_{lin} \\    B_{lin}\\end{bmatrix}$$\n$$2式:C_{XYZ} &#x3D; r(w_rR) + g(w_gR) + b(w_bB)$$\n$$2式矩陣:C_{XYZ} &#x3D; [R,G,B]\\begin{bmatrix}    w_r&amp;0&amp;0 \\    0&amp;w_g&amp;0 \\    0&amp;0&amp;w_b\\end{bmatrix}\\begin{bmatrix}    r \\    g \\    b\\end{bmatrix}&#x3D;[w_rR,w_gR,w_bB]C_{RGB}$$\n$$C_{XYZ} &#x3D;\\begin{bmatrix}    0.64&amp;0.30&amp;0.15 \\    0.33&amp;0.60&amp;0.06 \\    0.03&amp;0.10&amp;0.79\\end{bmatrix}\\begin{bmatrix}    0.6445&amp;0&amp;0 \\    0&amp;1.1919&amp;0 \\    0&amp;0&amp;1.2029\\end{bmatrix}\\begin{bmatrix}    r \\    g \\    b\\end{bmatrix}&#x3D;\\begin{bmatrix}0.4125 &amp; 0.3576 &amp; 0.1804 \\0.2127 &amp; 0.7151 &amp; 0.0722 \\0.0193 &amp; 0.1192 &amp; 0.9503\\end{bmatrix}C_{RGB}$$\n因此 sRGB 到 XYZ 的轉換矩陣M為( $C_{XYZ} &#x3D; M*C{sRGB}$ ):\n$$M &#x3D; [w_rR,w_gR,w_bB] &#x3D;\\begin{bmatrix}0.4125 &amp; 0.3576 &amp; 0.1804 \\0.2127 &amp; 0.7151 &amp; 0.0722 \\0.0193 &amp; 0.1192 &amp; 0.9503\\end{bmatrix}$$\n同理可證，XYZ 到 sRGB 的轉換矩陣為M的逆矩陣( $M^{-1}*C_{XYZ} &#x3D; C{sRGB}$ ):\n$$M &#x3D; [w_rR,w_gR,w_bB]^{-1} &#x3D;\\begin{bmatrix}3.2403 &amp; -1.5371 &amp; -0.4985 \\-0.9693 &amp; 1.8760 &amp; 0.0416 \\0.0556 &amp; -0.2040 &amp; 1.0572\\end{bmatrix}$$\n\n\n參考資料\n色彩空间基础\n\n","slug":"GraphicQuest/GQ005 Gamma校正 和 色彩空間","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"},{"id":"b289c42ae875c6d0fcba6aac91ffcfc9","title":"相機與透鏡","content":"1.1 相機與透鏡成像的背後都需要拍照，無論是光柵化還是光線追蹤，用合成的方法來生成光，最後使用一台相機來捕捉光\n因此，成像 &#x3D; 合成光 + 捕捉光\n2.1 相機的組成Pinholes &amp; Lenses form image on Sensor (小孔成像)\n\n快門控制光進入傳感器精確的曝光時間 Shutter Exposes Sensor For Precise Duration\n快門可以控制光進入相機傳感器的時間\n傳感器上每個點都會記錄來自各個方向的光的信息，所以傳感器記錄的是irradiance（輻照度，表示各種頻率輻射的總量)\n\n2.2 針孔相機 Pinhole Camera針孔相機成像是沒有景深的，我們做光線追踪的時候用的也是針孔相機，所以也是無法產生景深模糊的，如果我們能模擬光線與透鏡的作用，那麼我們也可以得到有景深的畫面\n3.1 視場(FOV)對於固定的傳感器尺寸，減小焦距會增加視野 For a fixed sensor size, decreasing the focal length increases the field of view\n\n視場代表著攝像頭能夠觀察到的最大範圍，通常以角度來表示，視場越大， 觀測範圍越大。\n視場FOV是在攝像機的前面的寬度h和聚焦距離f，可以推出FOV。\n\n\n視場與傳感器大小和焦距都有關係，所以人們通常規定以 35mm 格式膠片 (36 x 24mm) 上使用的鏡頭焦距來表示視場角 For historical reasons, it is common to refer to angular field of view by focal length of a lens used on a 35mm-format film (36 x 24mm)\n\nFOV關係到傳感器和鏡頭到傳感器的距離有關。\n改變聚焦，就改變了f，視場發生變化，拍攝同樣的畫面，獲得圖形的類型不同\n相同的視場調整聚焦的距離。\n\n\n3.1 曝光(Exposure)曝光度是拍攝的時間和光照幅度，照光幅度大小關係到光圈和焦距\n\n\n\n\n\n\n\n\n\nH &#x3D; T x E (Exposure &#x3D; time x irradiance) 曝光時間由快門控制，irradiance由光圈與焦距決定控制曝光的三要素：\n\n光圈 Aperture size\n快門 Shutter speed\n感光度 ISO gain\n\n\n3.2 光圈 Aperture size (F-Stop)表格對應的光圈和快門速度可以得到幾乎等效的曝光（比如光圈f4.0到f8.0光圈直徑減小到1&#x2F;2，面積變為原來的1&#x2F;4，所以快門速度相應的要補償4倍） Example: these pairs of aperture and shutter speed give equivalent exposure\n從4到8f的光圈，在其他不變的條件下，要是它畫面不變，那快門的時間從1&#x2F;60增大到1&#x2F;15。\n\nF-Number (F-Stop):\n\nWritten as FN or F&#x2F;N. N is the f-number\n在光學中，一個光學系統中的焦比（英語：f-number，或稱F值、F比例、相對孔徑、光圈值、光圈系数等，习惯上也简称「光圈」）表達鏡頭的焦距和光圈直徑大小的關係。\n\n3.3 快門 Shutter speed如果快門速度過慢，手持不穩或物體運動速度很快時容易產生運動模糊 Motion blur: handshake, subject movement\n運動模糊是因為快門打開的時間內物體發生了運動，傳感器會把這個過程的光線都記錄下來，並且傳感器又有平均的效果，於是產生了運動模糊，也可以從反走樣的角度理解，只不過拍照是在時間上採樣 Tip: think about anti-aliasing\n螺旋槳是因為快門關閉的時間不同，進來的光線在時間上差別，螺旋槳就被扭曲變形了。快門關乎到運動模糊的情況。\n\n機械快門會產生果凍效應 Rolling shutter: different parts of photo taken at different times\n3.4 感光度 ISO gain感光度理解為在模數轉換前對信號進行的增益，相當於在對結果相乘 Multiply signal before analog-to-digital conversion\n\n膠片：感光度會帶來顆粒 Film: trade sensitivity for grain\n數碼：感光度會帶來噪點 Digital: trade sensitivity for noise感光度是線性的（ISO 200需要ISO 100一半的光） Linear effect (ISO 200 needs half the light as ISO 100)\n\nIOS關係到光圈的大小，它的光圈越大，它獲取到的光越多。如果在環境光比較暗的地方，拉到光圈的大小提高畫面的亮度，但它也同時帶來的很多的躁點，這個有點像光子在受光的面積上面光子的不足造成的。\n在IOS基礎上，它乘上一個數，畫面亮度就發生改變。下面圖片展示不同亮度場景，IOS改變它們相同畫面亮度。\n\n3.5 各種效果圖\n4.1 透鏡現在的相機基本都有很複雜的透鏡組 Real Lens Designs Are Highly Complex\n現實中的的一些透鏡並不是我們假設的理想透鏡，它無法將光線會聚到一點 Real plano-convex lens (spherical surface shape). Lens does not converge rays to a point anywhere\n在理想透鏡 (Ideal Thin Lens) 中，進入透鏡的所有平行光線都通過其焦點 All parallel rays entering a lens pass through its focal point\n過一個焦點的所有光線在通過透鏡後將是平行的 All rays through a focal point will be in parallel after passing the lens\n焦距可以任意改變（現實種用透鏡組也可以實現） Focal length can be arbitrarily changed (in reality, yes!).\n\n\n這個是現實生活中的棱鏡，理想中的菱鏡是聚焦到一個點。\n平行光在棱鏡折射，經過一點，可以改變棱鏡的焦點，也就是棱鏡動態改變。\n光線過棱鏡的中心點是不會發生改變的，平行光過對面的焦點。\n研究它物距和相距關係，相似三角形的做出相似比例。\n通過兩個式子相同的項，化簡可以得到光圈和物距、相距之間的關係\n\n5.1 景深這裡不作過多介紹，不常見\n提高內容\n景深推導\n\n\n\n\n","slug":"GraphicQuest/GQ008 相機與透鏡","date":"2022-12-14T14:00:28.000Z","categories_index":"遊戲開發筆記","tags_index":"Computer Graphic","author_index":"tom_ci"}]